{
    "/home/dev/project/cloud-services/backend/bas-api/src/service/alarm-setting-service.ts": "import { alarmSettingDao } from '@bas/database/dao';\nimport * as objectMapper from 'object-mapper';\nimport { alarmSettingMapper } from '@bas/database/mapper/alarm-setting-mapper';\nimport {\n  AlarmCondition,\n  AlarmSettingData,\n  AlarmSettingDto,\n  AlarmSensor,\n} from '@bas/database/dto/response/alarm-setting-dto';\nimport { sequelizeConnection } from '@bas/database';\nimport { internalErrorCode } from '@bas/constant';\nimport NotFoundException from '@bas/api/errors/not-found-exception';\nimport { BadRequestException } from '@bas/api/errors';\nimport { alarmType } from '@bas/constant/alarm-status';\nimport { AlarmSettingUpdateDto } from '@bas/database/dto/request/alarm-setting-update-dto';\nimport { berthService } from '.';\nimport { Transaction } from 'sequelize';\n\nexport const findSetting = async (berthId: number) => {\n  const results = await alarmSettingDao.findSetting({ berthId });\n  const alarmSettings = results.map((row) => {\n    return objectMapper.merge(row, alarmSettingMapper) as AlarmSettingDto;\n  });\n\n  const response: AlarmSettingData = {};\n\n  alarmSettings.forEach((alarmSetting) => {\n    const {\n      alarmSensor,\n      alarmType,\n      id,\n      operator,\n      statusId,\n      value,\n      alarmZone,\n      message,\n      defaultValue,\n    } = alarmSetting;\n    if (!response[alarmZone]) {\n      response[alarmZone] = {};\n    }\n\n    if (alarmType === 'angle') {\n      if (!response[alarmZone][alarmType]) {\n        response[alarmZone][alarmType] = [];\n      }\n      (response[alarmZone][alarmType] as AlarmCondition[]).push({\n        alarmSettingId: id,\n        status_id: statusId,\n        operator,\n        value,\n        message,\n        defaultValue,\n      });\n    } else {\n      if (!response[alarmZone][alarmType]) {\n        response[alarmZone][alarmType] = {};\n      }\n\n      if (!(response[alarmZone][alarmType] as AlarmSensor)[alarmSensor]) {\n        (response[alarmZone][alarmType] as AlarmSensor)[alarmSensor] = [];\n      }\n\n      ((response[alarmZone][alarmType] as AlarmSensor)[alarmSensor] as AlarmCondition[]).push({\n        alarmSettingId: id,\n        status_id: statusId,\n        operator,\n        value,\n        message,\n        defaultValue,\n      });\n    }\n  });\n\n  return {\n    data: response,\n  };\n};\n\nexport const updateSetting = async (alarmSettingDto: AlarmSettingUpdateDto[]) => {\n  const ids = alarmSettingDto.map((alarmSetting) => alarmSetting.id);\n\n  const results = await alarmSettingDao.findByAllConditions(ids);\n  if (!results || ids.length > results.length) {\n    throw new NotFoundException(\n      `Alarm setting with id ${ids.join(', ')} not found`,\n      internalErrorCode.RESOURCE_NOT_FOUND\n    );\n  }\n\n  const alarmSettings = results.map((row) => {\n    return objectMapper.merge(row, alarmSettingMapper) as AlarmSettingDto;\n  });\n\n  const alarmSettingUpdate = alarmSettingDto.map((alarmSetting) => {\n    const findAlarmSetting = alarmSettings.find((a) => a.id === alarmSetting.id);\n    return {\n      ...alarmSetting,\n      statusId: findAlarmSetting?.statusId,\n    };\n  });\n\n  for (let i = 0; i < alarmSettingUpdate.length - 1; i++) {\n    if (alarmSettingUpdate[i].alarmType === alarmType.DISTANCE) {\n      if (\n        i === 0 &&\n        alarmSettings[0].defaultValue &&\n        alarmSettingUpdate[i].value >= alarmSettings[0].defaultValue\n      ) {\n        throw new BadRequestException(\n          `Value of id = ${alarmSettingUpdate[i].id} must less than ${alarmSettings[0].defaultValue}`\n        );\n      }\n\n      if (alarmSettingUpdate[i + 1].value >= alarmSettingUpdate[i].value) {\n        throw new BadRequestException(\n          `Value of id = ${alarmSettingUpdate[i + 1].id} must less than ${\n            alarmSettingUpdate[i].value\n          }`\n        );\n      }\n\n      if (alarmSettingUpdate[i + 1].value && i > 0 && !alarmSettingUpdate[i].value) {\n        throw new BadRequestException(\n          `Value of id = ${alarmSettingUpdate[i].id} must greater than ${\n            alarmSettingUpdate[i + 1].value\n          } and less than ${alarmSettingUpdate[i - 1].value}`\n        );\n      }\n\n      if (\n        alarmSettingUpdate[alarmSettingUpdate.length - 1].value == undefined ||\n        alarmSettingUpdate[alarmSettingUpdate.length - 1].value < 0\n      ) {\n        throw new BadRequestException(\n          `Value of id = ${\n            alarmSettingUpdate[alarmSettingUpdate.length - 1].id\n          } must greater than 0`\n        );\n      }\n    }\n\n    if (\n      alarmSettingUpdate[i].alarmType === alarmType.SPEED ||\n      alarmSettingUpdate[i].alarmType === alarmType.ANGLE\n    ) {\n      if (\n        i === 0 &&\n        alarmSettings[0].defaultValue &&\n        alarmSettingUpdate[i].value <= alarmSettings[0].defaultValue\n      ) {\n        throw new BadRequestException(\n          `Value of id = ${alarmSettingUpdate[i].id} must greater than ${alarmSettings[0].defaultValue}`\n        );\n      }\n\n      if (alarmSettingUpdate[i + 1].value <= alarmSettingUpdate[i].value) {\n        throw new BadRequestException(\n          `Value of id = ${alarmSettingUpdate[i + 1].id} must greater than ${\n            alarmSettingUpdate[i].value\n          }`\n        );\n      }\n\n      if (alarmSettingUpdate[i + 1] && i > 0 && !alarmSettingUpdate[i].value) {\n        throw new BadRequestException(\n          `Value of id = ${alarmSettingUpdate[i].id} must less than ${\n            alarmSettingUpdate[i + 1].value\n          } and greater than ${alarmSettingUpdate[i - 1].value}`\n        );\n      }\n    }\n\n    if (\n      (alarmSettingUpdate[alarmSettingUpdate.length - 1].alarmType === alarmType.ANGLE &&\n        alarmSettingUpdate[alarmSettingUpdate.length - 1].value > 90) ||\n      (alarmSettingUpdate[alarmSettingUpdate.length - 1].alarmType === alarmType.ANGLE &&\n        !alarmSettingUpdate[alarmSettingUpdate.length - 1].value)\n    ) {\n      throw new BadRequestException(\n        `Value of id = ${alarmSettingUpdate[alarmSettingUpdate.length - 1].id} must less than 90`\n      );\n    }\n  }\n\n  const response: any = [];\n\n  for (const alarmSetting of alarmSettingUpdate) {\n    const result = await alarmSettingDao.updateSetting(alarmSetting);\n\n    const res = objectMapper.merge(result[1][0], alarmSettingMapper) as AlarmSettingDto;\n\n    response.push(res);\n  }\n\n  return response;\n};\n\nexport const resetDataAlarmSetting = async (berthId: number) => {\n  const berth = await berthService.getBerthById(berthId);\n\n  const results = await alarmSettingDao.findSetting({ berthId });\n  const alarmSettings = results.map((row) => {\n    return objectMapper.merge(row, alarmSettingMapper) as AlarmSettingDto;\n  });\n\n  await sequelizeConnection.transaction(async (t) => {\n    const rs = defaultAlarmSettings(berth.limitZone1, berth.id);\n    for (const [index, alarmSetting] of alarmSettings.entries()) {\n      await alarmSettingDao.resetValueAlarmSetting(\n        {\n          ...rs[index],\n          id: alarmSetting.id,\n        } as AlarmSettingUpdateDto,\n        t\n      );\n    }\n  });\n};\n\nconst defaultAlarmSettings = (limitZone1: number | undefined, berthId: number) => {\n  return [\n    {\n      alarmType: 'distance',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 1,\n      operator: '>=',\n      message: null,\n      value: 10,\n      defaultValue: Number.isFinite(limitZone1) ? limitZone1 : null,\n    },\n    {\n      alarmType: 'distance',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 2,\n      operator: '>=',\n      message: null,\n      value: 5,\n      defaultValue: Number.isFinite(limitZone1) ? limitZone1 : null,\n    },\n    {\n      alarmType: 'distance',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 3,\n      operator: '>=',\n      message: null,\n      value: 0,\n      defaultValue: Number.isFinite(limitZone1) ? limitZone1 : null,\n    },\n    {\n      alarmType: 'distance',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 1,\n      operator: '>=',\n      message: null,\n      value: 10,\n      defaultValue: Number.isFinite(limitZone1) ? limitZone1 : null,\n    },\n    {\n      alarmType: 'distance',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 2,\n      operator: '>=',\n      message: null,\n      value: 5,\n      defaultValue: Number.isFinite(limitZone1) ? limitZone1 : null,\n    },\n    {\n      alarmType: 'distance',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 3,\n      operator: Number.isFinite(limitZone1) ? '>=' : '>',\n      message: null,\n      value: 0,\n      defaultValue: Number.isFinite(limitZone1) ? limitZone1 : null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 1,\n      operator: '<=',\n      message: null,\n      value: 30,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 2,\n      operator: '<=',\n      message: null,\n      value: 40,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 3,\n      operator: '<',\n      message: null,\n      value: null,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 1,\n      operator: '<=',\n      message: null,\n      value: 30,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 2,\n      operator: '<=',\n      message: null,\n      value: 40,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 3,\n      operator: '<',\n      message: null,\n      value: null,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'angle',\n      alarmSensor: null,\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 1,\n      operator: '<=',\n      message: null,\n      value: 5,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'angle',\n      alarmSensor: null,\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 2,\n      operator: '<=',\n      message: null,\n      value: 10,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'angle',\n      alarmSensor: null,\n      alarmZone: 'zone_1',\n      berthId: berthId,\n      statusId: 3,\n      operator: '<=',\n      message: null,\n      value: 90,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_2',\n      berthId: berthId,\n      statusId: 1,\n      operator: '<=',\n      message: null,\n      value: 40,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_2',\n      berthId: berthId,\n      statusId: 2,\n      operator: '<=',\n      message: null,\n      value: 60,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_2',\n      berthId: berthId,\n      statusId: 3,\n      operator: '<=',\n      message: null,\n      value: null,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_2',\n      berthId: berthId,\n      statusId: 1,\n      operator: '<=',\n      message: null,\n      value: 40,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_2',\n      berthId: berthId,\n      statusId: 2,\n      operator: '<=',\n      message: null,\n      value: 60,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_2',\n      berthId: berthId,\n      statusId: 3,\n      operator: '<',\n      message: null,\n      value: null,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'angle',\n      alarmSensor: null,\n      alarmZone: 'zone_2',\n      berthId: berthId,\n      statusId: 1,\n      operator: '<=',\n      message: null,\n      value: 10,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'angle',\n      alarmSensor: null,\n      alarmZone: 'zone_2',\n      berthId: berthId,\n      statusId: 2,\n      operator: '<=',\n      message: null,\n      value: 20,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'angle',\n      alarmSensor: null,\n      alarmZone: 'zone_2',\n      berthId: berthId,\n      statusId: 3,\n      operator: '<=',\n      message: null,\n      value: 90,\n      defaultValue: null,\n    },\n\n    {\n      alarmType: 'speed',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_3',\n      berthId: berthId,\n      statusId: 1,\n      operator: '<=',\n      message: null,\n      value: 40,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_3',\n      berthId: berthId,\n      statusId: 2,\n      operator: '<=',\n      message: null,\n      value: 60,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'left_sensor',\n      alarmZone: 'zone_3',\n      berthId: berthId,\n      statusId: 3,\n      operator: '<',\n      message: null,\n      value: null,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_3',\n      berthId: berthId,\n      statusId: 1,\n      operator: '<=',\n      message: null,\n      value: 40,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_3',\n      berthId: berthId,\n      statusId: 2,\n      operator: '<=',\n      message: null,\n      value: 60,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'speed',\n      alarmSensor: 'right_sensor',\n      alarmZone: 'zone_3',\n      berthId: berthId,\n      statusId: 3,\n      operator: '<',\n      message: null,\n      value: null,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'angle',\n      alarmSensor: null,\n      alarmZone: 'zone_3',\n      berthId: berthId,\n      statusId: 1,\n      operator: '<=',\n      message: null,\n      value: 10,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'angle',\n      alarmSensor: null,\n      alarmZone: 'zone_3',\n      berthId: berthId,\n      statusId: 2,\n      operator: '<=',\n      message: null,\n      value: 20,\n      defaultValue: null,\n    },\n    {\n      alarmType: 'angle',\n      alarmSensor: null,\n      alarmZone: 'zone_3',\n      berthId: berthId,\n      statusId: 3,\n      operator: '<=',\n      message: null,\n      value: 90,\n      defaultValue: null,\n    },\n  ];\n};\n\n\nexport const createNewAlarmSettingSet = async (berthId: number, limitZone1: number, transaction?: Transaction) => {\n  try {\n    const settingSet = defaultAlarmSettings(limitZone1, berthId);\n\n    const response: any = [];\n\n    for (const alarmSetting of settingSet) {\n      await alarmSettingDao.createAlarmSetting( berthId , alarmSetting, transaction);\n    }\n    return true;\n  } catch (error) {\n    console.log(error);\n    return false\n  }\n}\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/revoke-token.ts": "import cron from 'node-cron';\nimport { TIME_ZONE } from '@bas/constant';\n\nconst revokedTokens = new Map();\n\nfunction init() {\n  revokedTokens.clear();\n  initCron();\n}\n\nfunction revokeToken(token: string, ttlSeconds = 2 * 3600) {\n  revokedTokens.set(token, Date.now() + ttlSeconds * 1000);\n}\n\nfunction isTokenRevoked(token: string) {\n  const expiry = revokedTokens.get(token);\n  if (expiry && expiry > Date.now()) {\n    return true;\n  }\n  revokedTokens.delete(token);\n  return false;\n}\n\nfunction cleanup() {\n  const now = Date.now();\n  revokedTokens.forEach((expiry, token) => {\n    if (expiry < now) {\n      revokedTokens.delete(token);\n    }\n  });\n}\n\nfunction initCron() {\n  // cron: once per hour\n  cron.schedule('* 0 * * *', cleanup, { timezone: TIME_ZONE });\n}\n\nexport { revokeToken, isTokenRevoked, init };\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/berth-service.ts": "import { BerthDetailDto } from '@bas/database/dto/response/berth-detail-dto';\nimport {\n  BerthFilter,\n  resetBerthParam,\n  StartRecordAlarmPayload,\n  StartRecordPayload,\n} from './typing';\nimport { alarmSettingDao, berthDao } from '@bas/database/dao';\nimport * as objectMapper from 'object-mapper';\nimport { berthDetailMapper } from '@bas/database/mapper/berth-mapper';\nimport NotFoundException from '@bas/api/errors/not-found-exception';\nimport { internalErrorCode } from '@bas/constant';\nimport { BerthUpdateDto } from '@bas/database/dto/request/berth-update-dto';\nimport { BerthConfigDto } from '@bas/database/dto/request/berth-config-dto';\nimport { BerthStatus, fromBerthStatus, toBerthStatus } from '@bas/constant/berth-status';\nimport {\n  alarmSettingService,\n  kafkaService,\n  queueService,\n  realtimeService,\n  recordService,\n  vesselService,\n} from './index';\nimport { sequelizeConnection } from '@bas/database';\nimport { BadRequestException } from '@bas/api/errors';\nimport { generateRecordSession } from '@bas/utils';\nimport moment from 'moment-timezone';\nimport { recordCreateMapper } from '@bas/database/mapper/record-mapper';\nimport { BAS_RECORD_DATA } from '@bas/constant/kafka-topic';\nimport {\n  AlarmCondition,\n  AlarmSensor,\n  AlarmSettingData,\n  AlarmSettingDto,\n} from '@bas/database/dto/response/alarm-setting-dto';\nimport { alarmSettingMapper } from '@bas/database/mapper/alarm-setting-mapper';\n\nexport const getBerthById = async (berthId: number) => {\n  const result = await berthDao.getBerthInfo(berthId);\n  if (!result) {\n    throw new NotFoundException(\n      `Berth with id ${berthId} not found`,\n      internalErrorCode.RESOURCE_NOT_FOUND\n    );\n  }\n  const record = await recordService.getCurrentRecord(berthId);\n  const res = objectMapper.merge(result, berthDetailMapper) as BerthDetailDto;\n  if (record) {\n    res.record = {\n      berthId: record.berthId,\n      vesselId: record.vesselId,\n      id: record.id,\n      sessionId: record.sessionId,\n      endTime: record.endTime ? moment(record.endTime).toDate().toISOString() : null,\n      startTime: moment(record.startTime).toDate().toISOString(),\n    };\n  }\n  return res;\n};\n\nexport const deleteBerth = async (berthId: number) => {\n  const isRecording = await recordService.getCurrentRecord(berthId);\n  if (isRecording) {\n    throw new BadRequestException(\n      `Berth with id ${berthId} is recording`,\n      internalErrorCode.INVALID_INPUT\n    );\n  }\n\n  const result = await berthDao.deleteBerth(berthId);\n  if (result) {\n    realtimeService.removeBerthRealtime(berthId);\n  }\n  if (!result) {\n    throw new NotFoundException(\n      `Berth with id ${berthId} not found`,\n      internalErrorCode.RESOURCE_NOT_FOUND\n    );\n  }\n  return result;\n};\n\nexport const getAllBerths = async (filter: BerthFilter) => {\n  const result = await berthDao.getAllBerths(filter);\n  const data = result.rows.map((row) => {\n    return objectMapper.merge(row, berthDetailMapper) as BerthDetailDto;\n  });\n  return {\n    data,\n    count: result.count,\n  };\n};\n\nexport const updateBerth = async (berthId: number, data: BerthUpdateDto, modifier: string) => {\n  const { limitZone1, limitZone2, limitZone3 } = data;\n  const berth = await berthDao.getBerthInfo(berthId);\n  if (!berth) {\n    throw new NotFoundException(\n      `Berth with id ${berthId} not found`,\n      internalErrorCode.RESOURCE_NOT_FOUND\n    );\n  }\n  const results = await alarmSettingDao.findSetting({\n    berthId,\n    alarmType: 'distance',\n    alarmZone: 'zone_1',\n  });\n  const alarmSettings = results.map((row) => {\n    return objectMapper.merge(row, alarmSettingMapper) as AlarmSettingDto;\n  });\n\n  if (data.limitZone1) {\n    if (alarmSettings[0].value >= +data.limitZone1) {\n      throw new BadRequestException(\n        `Value of limitZone1 must greater than ${alarmSettings[0].value}`\n      );\n    }\n\n    await alarmSettingDao.updateDefaultValue(+data.limitZone1, berthId);\n  }\n\n  if (limitZone1 && limitZone2 && limitZone3) {\n    if (+limitZone1 >= +limitZone2 || +limitZone2 >= +limitZone3) {\n      throw new BadRequestException('Invalid limit zone value', internalErrorCode.INVALID_INPUT);\n    }\n  }\n  const updated = await berthDao.updateBerth(berthId, data, modifier);\n  return objectMapper.merge(updated[1][0], berthDetailMapper) as BerthDetailDto;\n};\n\nexport const configurationBerth = async (\n  berthId: number,\n  data: BerthConfigDto,\n  modifier: string\n) => {\n  const berth = await berthDao.getBerthInfo(berthId);\n  if (!berth) {\n    throw new NotFoundException(\n      `Berth with id ${berthId} not found`,\n      internalErrorCode.RESOURCE_NOT_FOUND\n    );\n  }\n  let isSend = true;\n  const res = await sequelizeConnection.transaction(async (t) => {\n    let vessel = (await vesselService.upsertVessel(data.vessel, t))[0];\n    const existRecord = await recordService.getCurrentRecord(berthId, t);\n\n    if (existRecord) {\n      isSend = false;\n    }\n\n    const updated = await berthDao.updateBerth(\n      berthId,\n      {\n        distanceToRight: data.distanceToRight,\n        distanceToLeft: data.distanceToLeft,\n        vesselId: vessel.id,\n        status: data.status,\n        vesselDirection: data.vesselDirection,\n      },\n      modifier,\n      t\n    );\n    const mooringStatus =\n      fromBerthStatus(berth.status) === BerthStatus.AVAILABLE ||\n      fromBerthStatus(berth.status) === BerthStatus.BERTHING\n        ? BerthStatus.BERTHING\n        : BerthStatus.DEPARTING;\n\n    return existRecord\n      ? existRecord\n      : await recordService.createRecord(\n          {\n            berthId,\n            vesselId: vessel.id,\n            sessionId: generateRecordSession(berthId, vessel.id),\n            createdBy: modifier,\n            startTime: moment().utc().toDate(),\n            endTime: null,\n            vesselDirection: data.vesselDirection ? 1 : 0,\n            limitZone1: berth.limitZone1,\n            limitZone2: berth.limitZone2,\n            limitZone3: berth.limitZone3,\n            directionCompass: berth.directionCompass,\n            distanceFender: berth.distanceFender,\n            distanceDevice: berth.distanceDevice,\n            distanceToLeft: data.distanceToLeft,\n            distanceToRight: data.distanceToRight,\n            syncStatus: 'PENDING',\n            mooringStatus: mooringStatus,\n          },\n          t\n        );\n  });\n  if (isSend && res?.id) {\n    await kafkaService.produceKafkaData(\n      BAS_RECORD_DATA,\n      JSON.stringify({\n        berth_id: berthId,\n        session_id: res.id,\n        mode: 'start',\n        distance_left_sensor_to_fender: data.distanceToLeft,\n        distance_right_sensor_to_fender: data.distanceToRight,\n        distance_between_sensors: berth.distanceDevice,\n        limit_zone_1: berth.limitZone1,\n        limit_zone_2: berth.limitZone2,\n        limit_zone_3: berth.limitZone3,\n        alarm: await alarmSettingData(berthId),\n      } as StartRecordPayload)\n    );\n    realtimeService.addBerthToWatch(\n      berthId,\n      new Date(res.startTime).getTime(),\n      res?.mooringStatus == BerthStatus.BERTHING ? BerthStatus.BERTHING : BerthStatus.DEPARTING\n    );\n  }\n\n  return objectMapper.merge(res, recordCreateMapper);\n};\n\nconst alarmSettingData = async (berthId: number) => {\n  const results = await alarmSettingDao.findSetting({ berthId });\n\n  const alarmSettings = results.map((row) => {\n    return objectMapper.merge(row, alarmSettingMapper) as AlarmSettingDto;\n  });\n\n  const response: AlarmSettingData = {};\n\n  alarmSettings.forEach((alarmSetting) => {\n    const { alarmSensor, alarmType, operator, statusId, value, alarmZone } = alarmSetting;\n    if (!response[alarmZone]) {\n      response[alarmZone] = {};\n    }\n\n    if (alarmType === 'angle') {\n      if (!response[alarmZone][alarmType]) {\n        response[alarmZone][alarmType] = [];\n      }\n      (response[alarmZone][alarmType] as AlarmCondition[]).push({\n        status_id: statusId,\n        operator,\n        value,\n      });\n    } else {\n      if (!response[alarmZone][alarmType]) {\n        response[alarmZone][alarmType] = {};\n      }\n\n      if (!(response[alarmZone][alarmType] as AlarmSensor)[alarmSensor]) {\n        (response[alarmZone][alarmType] as AlarmSensor)[alarmSensor] = [];\n      }\n\n      ((response[alarmZone][alarmType] as AlarmSensor)[alarmSensor] as AlarmCondition[]).push({\n        status_id: statusId,\n        operator,\n        value,\n      });\n    }\n  });\n\n  return response;\n};\n\nconst validateStatus = (currentStatus: BerthStatus | null, changedStatus: BerthStatus | null) => {\n  if (!currentStatus || !changedStatus) {\n    throw new BadRequestException('Invalid change status', internalErrorCode.INVALID_INPUT);\n  }\n  switch (currentStatus) {\n    case BerthStatus.AVAILABLE:\n      if ([BerthStatus.MOORING].includes(changedStatus)) {\n        throw new BadRequestException('Invalid change status', internalErrorCode.INVALID_INPUT);\n      }\n      break;\n    case BerthStatus.MOORING:\n      if ([BerthStatus.AVAILABLE].includes(changedStatus)) {\n        throw new BadRequestException('Invalid change status', internalErrorCode.INVALID_INPUT);\n      }\n      break;\n    case BerthStatus.BERTHING:\n      if ([BerthStatus.MOORING, BerthStatus.AVAILABLE].includes(changedStatus)) {\n        throw new BadRequestException('Invalid change status', internalErrorCode.INVALID_INPUT);\n      }\n      break;\n    case BerthStatus.DEPARTING:\n      if (\n        [BerthStatus.AVAILABLE, BerthStatus.MOORING, BerthStatus.BERTHING].includes(changedStatus)\n      ) {\n        throw new BadRequestException('Invalid change status', internalErrorCode.INVALID_INPUT);\n      }\n      break;\n    default:\n      return;\n  }\n};\n\nexport const resetBerth = async (params: resetBerthParam) => {\n  let { berthId, status, modifier, isError, isFinish } = params;\n  let isSync = false;\n  const berth = await berthDao.getBerthInfo(berthId);\n  if (!berth) {\n    throw new NotFoundException(\n      `Berth with id ${berthId} not found`,\n      internalErrorCode.RESOURCE_NOT_FOUND\n    );\n  }\n\n  if (isFinish && fromBerthStatus(berth.status) == BerthStatus.DEPARTING) {\n    status = BerthStatus.AVAILABLE;\n  }\n\n  const existRecord = await recordService.getCurrentRecord(berthId);\n  if (existRecord) {\n    await kafkaService.produceKafkaData(\n      BAS_RECORD_DATA,\n      JSON.stringify({\n        berth_id: berthId,\n        session_id: existRecord.id,\n        mode: 'stop',\n      } as StartRecordPayload)\n    );\n    await recordService.endRecord(existRecord.id);\n    realtimeService.removeBerthFromWatch(berthId);\n    if (isError) {\n      await recordService.remove(existRecord.id);\n    }\n    isSync = await recordService.sync(existRecord.id);\n  }\n  const updated = await berthDao.updateBerth(\n    berthId,\n    {\n      ...(status == BerthStatus.AVAILABLE\n        ? {\n            vesselId: null,\n            vesselDirection: null,\n          }\n        : {}),\n      status: toBerthStatus(status),\n    },\n    modifier\n  );\n  if (existRecord?.id) {\n    await queueService.pushToQueue('alarm-save', { type: 'stop', recordId: existRecord.id });\n  }\n\n  if (status == BerthStatus.AVAILABLE) {\n    await alarmSettingService.resetDataAlarmSetting(berthId);\n  }\n\n  return {\n    data: objectMapper.merge(updated[1][0], berthDetailMapper) as BerthDetailDto,\n    isSync,\n  };\n};\n\nexport const createBerth = async (data: BerthUpdateDto, modifier: string) => {\n  const { limitZone1 = 60, limitZone2 = 120, limitZone3 = 200 } = data;\n  if (limitZone1 && limitZone2 && limitZone3) {\n    if (+limitZone1 >= +limitZone2 || +limitZone2 >= +limitZone3) {\n      throw new BadRequestException('Invalid limit zone value', internalErrorCode.INVALID_INPUT);\n    }\n  }\n\n  const res = await sequelizeConnection.transaction(async (t) => {\n    const result = await berthDao.createBerth(data, modifier, t);\n    await alarmSettingService.createNewAlarmSettingSet(result.id, limitZone1, t);\n    return result;\n  });\n  if (res.leftDeviceId && res.rightDeviceId)\n    realtimeService.addBerthRealtime(res.id, res.leftDeviceId, res.rightDeviceId);\n\n  return objectMapper.merge(res, berthDetailMapper) as BerthDetailDto;\n};\n\nexport const getAllBerthWithSensor = () => {\n  return berthDao.getAllBerthWithSensor();\n};\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/record-service.ts": "import { alarmDao, recordDao, recordHistoryDao } from '@bas/database/dao';\nimport { AlarmDataUnit, RecordFilter, RecordHistoryQueryParams } from './typing';\nimport { RecordDetailDto } from '@bas/database/dto/response/record-detail.dto';\nimport * as objectMapper from 'object-mapper';\nimport { recordAggregateMapper, recordDetailMapper } from '@bas/database/mapper/record-mapper';\nimport { Transaction } from 'sequelize';\nimport { cloudService, queueService, recordHistoryService } from './index';\nimport RecordHistory from '@bas/database/models/record-history-model';\nimport { Record } from '@bas/database';\nimport { alarmStatus } from '@bas/constant/alarm-status';\nimport {\n  recordHistoryChartMapper,\n  recordHistoryMapper,\n  recordHistoryMapperReverse,\n} from '@bas/database/mapper/record-history-mapper';\nimport { BadRequestException } from '@bas/api/errors';\nimport { internalErrorCode, RecordSyncStatus } from '@bas/constant';\n\nexport const findAll = async (recordFilter: RecordFilter) => {\n  const result = await recordDao.findAll(recordFilter);\n\n  const data = result.rows.map((row) => {\n    return objectMapper.merge(row, recordDetailMapper) as RecordDetailDto;\n  });\n\n  return {\n    data,\n    count: result.count,\n  };\n};\n\nexport const getAggregatesByRecordId = async (recordId: number) => {\n  const result = await recordDao.getAggregatesByRecordId(recordId);\n\n  const aggregates = objectMapper.merge(\n    result.aggregates[0]?.dataValues || {},\n    recordAggregateMapper\n  );\n  return {\n    data: {\n      aggregates,\n    },\n  };\n};\n\nexport const getChartByRecordId = async (recordId: number) => {\n  const result = await recordDao.getChartByRecordId(recordId);\n\n  const chart = result?.chart?.map((recordHistory) => {\n    return objectMapper.merge(recordHistory, recordHistoryChartMapper);\n  });\n  return {\n    data: {\n      chart,\n    },\n  };\n};\n\nexport const getRecordHistoryByRecordId = async (\n  recordId: number,\n  recordHistoryQueryParams: RecordHistoryQueryParams\n) => {\n  const result = await recordDao.getRecordHistoryByRecordId(recordId, recordHistoryQueryParams);\n\n  const record = objectMapper.merge(result.record || {}, recordDetailMapper);\n  const recordHistories = result.recordHistories.map((recordHistory) => {\n    return objectMapper.merge(recordHistory, recordHistoryMapper);\n  });\n\n  return {\n    data: {\n      ...record,\n      recordHistories,\n    },\n    count: result.count,\n  };\n};\n\nexport const getRecordHistoryByRecordIdWithoutPagination = async (recordId: number) => {\n  const result = await recordDao.findAllWithoutPagination(recordId);\n\n  const record = objectMapper.merge(result.record || {}, recordDetailMapper);\n  const recordHistories = result.recordHistories.map((recordHistory) => {\n    return objectMapper.merge(recordHistory, recordHistoryMapper);\n  });\n\n  const resultAggregates = await recordDao.getAggregatesByRecordId(recordId);\n\n  const aggregates = objectMapper.merge(\n    resultAggregates.aggregates[0]?.dataValues || {},\n    recordAggregateMapper\n  );\n\n  const resultChart = await recordDao.getChartByRecordId(recordId);\n\n  const chart = resultChart?.chart?.map((recordHistory) => {\n    return objectMapper.merge(recordHistory, recordHistoryChartMapper);\n  });\n\n  return {\n    ...record,\n    recordHistories,\n    aggregates,\n    chart,\n  };\n};\n\nexport const remove = async (id: number) => {\n  const recordExist = await recordDao.getRecordById(id);\n  if (!recordExist?.endTime) {\n    throw new BadRequestException('Record is not ended yet', internalErrorCode.INVALID_INPUT);\n  }\n  return await recordDao.remove(id);\n};\n\nexport const getCurrentRecord = async (berthId: number, t?: Transaction) => {\n  return recordDao.getCurrentRecord(berthId, t);\n};\n\nexport const createRecord = async (data: any, t?: Transaction) => {\n  return recordDao.createRecord(data, t);\n};\n\nexport const endRecord = async (recordId: number, t?: Transaction) => {\n  return recordDao.endRecord(recordId, t);\n};\n\nexport const getRecordById = async (recordId: number) => {\n  return recordDao.getRecordByIdAndNotEnd(recordId);\n};\n\nexport const findLatestRecord = async (\n  berthId: number,\n  startTime: Date,\n  endTime: Date,\n  raw?: boolean\n) => {\n  //   get data history 24h last\n  const recordHistory = await recordHistoryService.getAllRecordHistoryBetweenTime(\n    berthId,\n    startTime,\n    endTime\n  );\n  const records = await recordDao.findRecordByIds(recordHistory.map((record) => record.recordId));\n  if (!raw) {\n    return recordHistory.length > 0 ? await convertToAlarmData(recordHistory, records) : [];\n  } else {\n    return recordHistory.map((frame) => {\n      const record = records.find((record) => record.id === frame.recordId);\n      return objectMapper.merge(\n        frame,\n        recordHistoryMapperReverse(\n          record?.berth?.leftDevice?.id || 1,\n          record?.berth?.rightDevice?.id || 2\n        )\n      );\n    });\n  }\n};\n\nconst SIDE = {\n  LEFT: 1,\n  RIGHT: 2,\n};\n\nconst convertToAlarmData = async (frames: RecordHistory[], records?: Record[]) => {\n  let alarmData: AlarmDataUnit[] = [];\n  let leftSpeed: AlarmDataUnit[] = [];\n  let rightSpeed: AlarmDataUnit[] = [];\n  let leftDistance: AlarmDataUnit[] = [];\n  let rightDistance: AlarmDataUnit[] = [];\n  let angle: AlarmDataUnit[] = [];\n\n  frames.forEach((alarm, index) => {\n    const currentLeftSpeed = extractAlarmData(alarm, 'speed', SIDE.LEFT);\n    if (\n      currentLeftSpeed.value !== leftSpeed[leftSpeed.length - 1]?.value &&\n      currentLeftSpeed.alarm !== alarmStatus.OPERATOR\n    ) {\n      if (leftSpeed[leftSpeed.length - 1]) {\n        leftSpeed[leftSpeed.length - 1].endTime = currentLeftSpeed.startTime;\n      }\n      leftSpeed.push(currentLeftSpeed);\n    }\n\n    const currentRightSpeed = extractAlarmData(alarm, 'speed', SIDE.RIGHT);\n    if (\n      currentRightSpeed.value !== rightSpeed[rightSpeed.length - 1]?.value &&\n      currentRightSpeed.alarm !== alarmStatus.OPERATOR\n    ) {\n      if (rightSpeed[rightSpeed.length - 1]) {\n        rightSpeed[rightSpeed.length - 1].endTime = currentRightSpeed.startTime;\n      }\n      rightSpeed.push(currentRightSpeed);\n    }\n\n    const currentLeftDistance = extractAlarmData(alarm, 'distance', SIDE.LEFT);\n    if (\n      currentLeftDistance.value !== leftDistance[leftDistance.length - 1]?.value &&\n      currentLeftDistance.alarm &&\n      currentLeftDistance.alarm > alarmStatus.WARNING\n    ) {\n      if (leftDistance[leftDistance.length - 1]) {\n        leftDistance[leftDistance.length - 1].endTime = currentLeftDistance.startTime;\n      }\n      leftDistance.push(currentLeftDistance);\n    }\n\n    const currentRightDistance = extractAlarmData(alarm, 'distance', SIDE.RIGHT);\n    if (\n      currentRightDistance.value !== rightDistance[rightDistance.length - 1]?.value &&\n      currentRightDistance.alarm &&\n      currentRightDistance.alarm > alarmStatus.WARNING\n    ) {\n      if (rightDistance[rightDistance.length - 1]) {\n        rightDistance[rightDistance.length - 1].endTime = currentRightDistance.startTime;\n      }\n      rightDistance.push(currentRightDistance);\n    }\n\n    const currentAngle = extractAlarmData(alarm, 'angle');\n    if (\n      currentAngle.value !== angle[angle.length - 1]?.value &&\n      currentAngle.alarm !== alarmStatus.OPERATOR\n    ) {\n      if (angle[angle.length - 1]) {\n        angle[angle.length - 1].endTime = currentAngle.startTime;\n      }\n      angle.push(currentAngle);\n    }\n  });\n\n  if (leftSpeed.length) {\n    leftSpeed[leftSpeed.length - 1].endTime = records?.find(\n      (record) => record.id === leftSpeed[leftSpeed.length - 1]?.recordId\n    )?.endTime;\n  }\n\n  if (rightSpeed.length) {\n    rightSpeed[rightSpeed.length - 1].endTime = records?.find(\n      (record) => record.id === rightSpeed[rightSpeed.length - 1]?.recordId\n    )?.endTime;\n  }\n\n  if (leftDistance.length) {\n    leftDistance[leftDistance.length - 1].endTime = records?.find(\n      (record) => record.id === leftDistance[leftDistance.length - 1]?.recordId\n    )?.endTime;\n  }\n\n  if (rightDistance.length) {\n    rightDistance[rightDistance.length - 1].endTime = records?.find(\n      (record) => record.id === rightDistance[rightDistance.length - 1]?.recordId\n    )?.endTime;\n  }\n\n  if (angle.length) {\n    angle[angle.length - 1].endTime = records?.find(\n      (record) => record.id === angle[angle.length - 1]?.recordId\n    )?.endTime;\n  }\n\n  alarmData.push(...leftSpeed, ...rightSpeed, ...leftDistance, ...rightDistance, ...angle);\n  return alarmData\n    .filter((item) => item.alarm != alarmStatus.OPERATOR)\n    .sort((a, b) => b.startTime.getTime() - a.startTime.getTime());\n};\n\nconst extractAlarmData = (alarmData: RecordHistory, type: string, side?: number): AlarmDataUnit => {\n  switch (type) {\n    case 'speed':\n      if (side === SIDE.LEFT) {\n        return {\n          startTime: alarmData.time,\n          value: alarmData.leftSpeed,\n          alarm: alarmData.LSpeedAlarm,\n          zone: alarmData.LSpeedZone,\n          recordId: alarmData.recordId,\n          type: 'speed',\n          side: SIDE.LEFT,\n        };\n      } else {\n        return {\n          startTime: alarmData.time,\n          value: alarmData.rightSpeed,\n          alarm: alarmData.RSpeedAlarm,\n          zone: alarmData.RSpeedZone,\n          recordId: alarmData.recordId,\n          type: 'speed',\n          side: SIDE.RIGHT,\n        };\n      }\n    case 'distance':\n      if (side === SIDE.LEFT) {\n        return {\n          startTime: alarmData.time,\n          value: alarmData.leftDistance,\n          alarm: alarmData.LDistanceAlarm,\n          zone: alarmData.LDistanceZone,\n          recordId: alarmData.recordId,\n          type: 'distance',\n          side: SIDE.LEFT,\n        };\n      } else {\n        return {\n          startTime: alarmData.time,\n          value: alarmData.rightDistance,\n          alarm: alarmData.RDistanceAlarm,\n          zone: alarmData.RDistanceZone,\n          recordId: alarmData.recordId,\n          type: 'distance',\n          side: SIDE.RIGHT,\n        };\n      }\n    default:\n      return {\n        startTime: alarmData.time,\n        value: alarmData.angle,\n        alarm: alarmData.angleAlarm,\n        zone: alarmData.angleZone,\n        recordId: alarmData.recordId,\n        type: 'angle',\n      };\n  }\n};\n\nexport const sync = async (recordId: number) => {\n  const result = await recordDao.findAllWithoutPagination(recordId);\n\n  if (!result) {\n    throw new BadRequestException('Record not found', internalErrorCode.INVALID_INPUT);\n  }\n\n  if (!result.record?.endTime) {\n    throw new BadRequestException('Record is ended', internalErrorCode.INVALID_INPUT);\n  }\n\n  const payload = {\n    recordInformation: {\n      ...result.record,\n      recordLocalId: result.record.id,\n      id: undefined,\n    },\n    frame:\n      result.recordHistories.map((recordHistory) => {\n        return objectMapper.merge(recordHistory, recordHistoryMapper);\n      }) || [],\n    berthInformation: {\n      ...result.record.berth?.dataValues,\n    },\n    vesselInformation: {\n      ...result.record.vessel?.dataValues,\n    },\n  };\n  const sync = await cloudService.syncRecordToCloud(payload);\n  const status = sync ? RecordSyncStatus.SUCCESS : RecordSyncStatus.FAILED;\n  await recordDao.updateStatus(recordId, status);\n\n  return sync;\n};\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/account-service.ts": "import { getIpAddress, logError, setCookieRefreshToken } from '@bas/utils';\nimport { accountDao } from '@bas/database/dao';\n\nimport bcrypt from 'bcrypt';\nimport UnauthorizedException from '@bas/api/errors/unauthorized-exception';\nimport { userService } from './index';\nimport { SystemRole } from '@bas/database/master-data';\nimport { roleMatrix } from '@bas/constant/role-matrix';\n\nconst authenticate = async (username: string, password: string, ipAddress : string) => {\n\n  const account = await accountDao.getAccountByUsername(username);\n  if (account == null) {\n    throw new UnauthorizedException('Username or password is invalid');\n  }\n\n  const checkPassword = account && (await bcrypt.compare(password, account.passwordHash));\n  if (!checkPassword) {\n    throw new UnauthorizedException('Username or password is invalid');\n  }\n  const user = await userService.getUserById(account.userId);\n  if (!user) {\n    throw new UnauthorizedException('Username or password is invalid');\n  }\n  const accessToken = userService.generateAccessToken(user);\n  const refreshToken = await userService.generateRefreshToken(user, ipAddress);\n  const defaultRoles = Object.values(SystemRole);\n  const roleCode = defaultRoles[user.roleId - 1];\n\n  return {\n    user,\n    permissions: roleMatrix[roleCode.toString()].map((permission: string) => permission),\n    accessToken,\n    refreshToken: refreshToken.token\n  };\n};\n\nexport { authenticate };\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/index.ts": "import * as userService from './user-service';\nimport * as accountService from './account-service';\nimport * as realtimeService from './realtime-service';\nimport * as revokeTokenService from './revoke-token';\nimport * as berthService from './berth-service';\nimport * as harborService from './harbor-service';\nimport * as recordService from './record-service';\nimport * as vesselService from './vessel-service';\nimport * as recordHistoryService from './record-history-service';\nimport * as cloudService from './cloud-service';\nimport * as kafkaService from './kafka-service';\nimport * as alarmSettingService from './alarm-setting-service';\nimport * as alarmService from './alarm-service';\nimport * as exportDataAlarmService from './export-data-alarm-service';\nimport * as queueService from './queue-service';\nimport * as authService from './auth-service';\nimport * as dataAppService from './data-app-service';\nimport * as axiosClient from './axios-client';\n\nexport {\n  userService,\n  accountService,\n  realtimeService,\n  revokeTokenService,\n  berthService,\n  harborService,\n  recordService,\n  vesselService,\n  recordHistoryService,\n  cloudService,\n  kafkaService,\n  alarmSettingService,\n  alarmService,\n  exportDataAlarmService,\n  queueService,\n  authService,\n  dataAppService,\n  axiosClient,\n};\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/axios-client.ts": "import axios from 'axios';\nimport { stringify } from 'querystring';\nconst axiosClient = axios.create({\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n  },\n  paramsSerializer: (params) => stringify(params),\n});\n\n// axiosClient.interceptors.request.use(async (config) => {});\n\naxiosClient.interceptors.response.use(\n  (response) => {\n    if (response && response.data) {\n      return response.data;\n    }\n    return response;\n  },\n  (error) => {\n    throw error;\n  }\n);\n\nconst axiosAri = axios.create({\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\naxiosAri.interceptors.response.use(\n  (response) => {\n    if (response && response.data) {\n      return response.data;\n    }\n    return response;\n  },\n  (error) => {\n    throw error;\n  }\n);\n\nexport { axiosClient, axiosAri };\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/harbor-service.ts": "import { harborDao } from '@bas/database/dao';\nimport { BerthFilter } from './typing';\nimport { HarborDetailDto } from '@bas/database/dto/response/harbor-detail-dto';\nimport NotFoundException from '@bas/api/errors/not-found-exception';\nimport { internalErrorCode } from '@bas/constant';\n\nexport const getHarborInfo = async (filter: BerthFilter) => {\n  const harbor = await harborDao.getHarborInfo();\n  if (!harbor) {\n    throw new NotFoundException('Harbor not found', internalErrorCode.RESOURCE_NOT_FOUND);\n  }\n  const data: HarborDetailDto = {\n    name: harbor.name,\n    nameEn: harbor.nameEn,\n    description: harbor.description,\n    address: harbor.address,\n    weatherWidgetUrl: harbor.weatherWidgetUrl,\n    weatherWidgetDashboardUrl: harbor.weatherWidgetDashboardUrl,\n  };\n  return data;\n}\n\n\nexport const configuration = async (body: any) => {\n  return (await harborDao.configuration(body))[1][0];\n}",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/permission-mapping.ts": "// permission-mapping.ts\nimport { CLOUD_PERMISSION } from '@bas/constant/cloud-permission';\n\nexport function mapApiPermissionsToRoles(apiPermissions: string[]): string[] {\n  const roles: string[] = [];\n\n  // Map permissions to roles\n  if (\n    apiPermissions.includes(CLOUD_PERMISSION.BAS_RECORDING_VIEW) &&\n    apiPermissions.includes(CLOUD_PERMISSION.BAS_RECORDING_CREATE) &&\n    apiPermissions.includes(CLOUD_PERMISSION.BAS_RECORDING_EDIT) &&\n    apiPermissions.includes(CLOUD_PERMISSION.BAS_RECORDING_DELETE)\n  ) {\n    roles.push('ADMIN');\n  } else if (\n    apiPermissions.includes(CLOUD_PERMISSION.BAS_RECORDING_VIEW) &&\n    apiPermissions.includes(CLOUD_PERMISSION.BAS_RECORDING_CREATE) &&\n    apiPermissions.includes(CLOUD_PERMISSION.BAS_RECORDING_EDIT)\n  ) {\n    roles.push('CONFIGURE');\n  } else if (apiPermissions.includes(CLOUD_PERMISSION.BAS_RECORDING_VIEW)) {\n    roles.push('VIEW');\n  }\n\n  return roles;\n}\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/mail-service.ts": "import { log, logError, logSuccess } from '@bas/utils';\nimport { formattedDateVN } from '@bas/utils/date';\nimport { MAIL_HOST, MAIL_PASSWORD, MAIL_PORT, MAIL_USER } from '@bas/config';\nimport nodemailer, { SendMailOptions, TransportOptions } from 'nodemailer';\n\nconst SEND_MAIL = true;\n\nconst logHistorySentMail = (isSuccess: boolean, date: Date, mailList: string[]) => {\n  const message = (isSuccess ? 'Thành công' : 'Thất bại') + ' khi gửi thông báo đến ';\n  log(`${formattedDateVN(date)} : ${message} ${mailList.join(', ')}`);\n  return `${formattedDateVN(date)}: ${message} ${mailList.join(', ')}`;\n};\n\nconst fillTemplate = (template: string, data: any) => {\n  if (!template || !data) {\n    return '';\n  }\n  for (const key in data) {\n    template = template.replace(`$${key}$`, data[key]);\n  }\n  return template;\n};\n\nconst transporter = nodemailer.createTransport({\n  host: MAIL_HOST,\n  secure: false,\n  port: MAIL_PORT,\n  auth: {\n    user: \"bas\",\n    pass: MAIL_PASSWORD,\n  },\n  tls: {\n    ciphers:'SSLv3',\n    rejectUnauthorized: false,\n  },\n  maxMessages: 10,\n} as TransportOptions);\n\ntransporter.verify((error, _) => {\n  if (error) {\n    logError(error.toString());\n  } else {\n    logSuccess('Server is ready to take our messages')\n  }\n});\n\nconst getMailOptions = (to: string[], subject: string, body: string) => {\n  return { from: `bas Notification' <${MAIL_USER}>`, to, subject, html: body } as SendMailOptions;\n};\n\nconst sendMail = async (options: SendMailOptions) => {\n  try {\n    if (SEND_MAIL) await transporter.sendMail(options);\n    return true;\n  } catch (error: any) {\n    log(error);\n    return false;\n  }\n};\nexport { fillTemplate, getMailOptions, logHistorySentMail, sendMail };\n\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/cloud-service.ts": "import { ORGANIZATION_ID, CLOUD_API_KEY_EXPIRES } from '@bas/config';\nimport { getPem } from '@bas/config/keys';\nimport { axiosCloud, encrypt } from '@bas/utils';\nimport { ENTRY_POINT } from '@bas/constant';\nimport fs from 'fs';\n\nconst getAPIKey = async () => {\n  const date = new Date().getTime() + Number(CLOUD_API_KEY_EXPIRES);\n  const content = `${ORGANIZATION_ID}_${date}`;\n  const publicKey = getPem();\n  return encrypt(content, publicKey);\n};\n\nconst syncRecordToCloud = async (data: any) => {\n  try {\n    const res = await axiosCloud.post(ENTRY_POINT.SYNC_PATH, data, {\n      headers: {\n        X_API_KEY: await getAPIKey(),\n      },\n      maxContentLength: Infinity,\n      maxBodyLength: Infinity,\n    });\n    return !!res.data;\n  } catch (error) {\n    console.log(error);\n    return false;\n  }\n};\n\nexport { syncRecordToCloud };\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/export-data-alarm-service.ts": "import { log } from '@bas/utils';\nimport Excel from 'exceljs';\nimport { Response } from 'express';\nimport moment from 'moment-timezone';\nimport { AlarmData } from './typing';\nimport { alarmStatus } from '@bas/constant/alarm-status';\nimport { useMessages } from '../locale';\n\nconst Columns = (lang : string) => [\n  {\n    header: useMessages('alarm-export.name.start-time', lang),\n    key: 'startTime',\n    width: 25,\n  },\n  {\n    header: useMessages('alarm-export.name.end-time', lang),\n    key: 'endTime',\n    width: 25,\n  },\n  {\n    header: useMessages('alarm-export.name.sessionId', lang),\n    key: 'sessionId',\n    width: 25,\n  },\n  {\n    header: useMessages('alarm-export.name.berth', lang),\n    key: 'berth',\n    width: 15,\n  },\n  {\n    header: useMessages('alarm-export.name.sensor', lang),\n    key: 'sensor',\n    width: 15,\n  },\n  {\n    header: useMessages('alarm-export.name.zone', lang),\n    key: 'zone',\n    width: 10,\n  },\n  {\n    header: useMessages('alarm-export.name.type', lang),\n    key: 'type',\n    width: 10,\n  },\n  {\n    header: useMessages('alarm-export.name.value', lang),\n    key: 'value',\n    width: 15,\n  },\n  {\n    header: useMessages('alarm-export.name.alarm', lang),\n    key: 'alarm',\n    width: 20,\n  },\n  {\n    header: useMessages('alarm-export.name.message', lang),\n    key: 'message',\n    width: 30,\n  },\n];\n\nconst alarmValueToText = (value: number, lang: string) => {\n  if(value === alarmStatus.WARNING) {\n    return useMessages('alarm-export.name.warning', lang)\n  } else if (value === alarmStatus.EMERGENCY) {\n    return useMessages('alarm-export.name.emergency', lang)\n  }\n}\n\nconst exportDataToExcel = async (res: Response, data: AlarmData[], lang: string) => {\n  const workbook = new Excel.Workbook();\n  const worksheet = workbook.addWorksheet(useMessages('alarm-export.title.alarm', lang));\n\n  worksheet.columns = Columns(lang);\n\n  const results = data?.map((e: AlarmData) => {\n    return {\n      ...e,\n      value: e.value.toFixed(2) as any,\n      startTime: moment(e.startTime).format('HH:mm:ss:SSS DD-MM-YYYY'),\n      endTime: moment(e.endTime).format('HH:mm:ss:SSS DD-MM-YYYY'),\n      berth: e.record.berth.name,\n      sensor: e.sensor.name,\n      alarm: alarmValueToText(e.alarm , lang),\n      sessionId: e.record.sessionId\n    };\n  });\n\n  worksheet.addRows(results);\n\n  let filename = `Alarmhistory_${moment().format('HH.mm.ss_DD.MM.YYYY')}_${lang}.xlsx`;\n  log(`Exporting ${filename}...`);\n  res.setHeader(\n    'Content-Type',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n  );\n  res.setHeader('Content-Disposition', 'attachment; filename=' + filename);\n\n  return workbook.xlsx.write(res).then(function () {\n    res.status(200).end();\n  });\n};\n\nexport { exportDataToExcel };\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/alarm-service.ts": "import { alarmDao } from '@bas/database/dao';\nimport * as objectMapper from 'object-mapper';\nimport { AlarmQueryParams } from './typing';\nimport { NotFound } from '@bas/api/errors';\nimport { alarmMapper } from '@bas/database/mapper/alarm-mapper';\nimport { AlarmDto } from '@bas/database/dto/response/alarm-dto';\nimport { InternalException } from '@bas/api/errors';\n\nconst findAll = async (alarmQueryParams: AlarmQueryParams) => {\n  const resultAlarm = await alarmDao.getAllAlarmByParams(alarmQueryParams);\n  const recordAlarms = resultAlarm.rows.map((row) => {\n    return objectMapper.merge(row.dataValues, alarmMapper) as AlarmDto;\n  });\n\n  return {\n    data: recordAlarms,\n    count: resultAlarm.count,\n  };\n};\n\nconst removeAlarm = async (id: number) => {\n  const recordExist = await alarmDao.getAlarmById(id);\n  if (!recordExist) {\n    throw new NotFound('Alarm is not found');\n  }\n  return await alarmDao.deleteAlarmById(id);\n};\n\nconst removeAllAlarm = async () => {\n  return await alarmDao.deleteALlAlarm();\n};\n\nconst saveAlarmFromQueue = async (data: any) => {\n  if (data?.type === 'stop') {\n    await alarmDao.endAllAlarm(data.recordId);\n  } else {\n    await alarmDao.createAlarmFromDataPoint(data.dataPoint, data.sensorIds);\n  }\n};\n\nconst findLatestAlarm = async (berthId: number, startTime: Date, endTime: Date) => {\n  try {\n    const data = await alarmDao.findLatestAlarm(berthId, startTime, endTime);\n    return data.map((row) => objectMapper.merge(row.toJSON(), alarmMapper) as AlarmDto);\n  } catch (error: any) {\n    throw new InternalException(error.message);\n  }\n};\n\nexport { findAll, removeAlarm, removeAllAlarm, saveAlarmFromQueue, findLatestAlarm };\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/queue-service.ts": "import kue, { DoneCallback, Job } from 'kue';\nimport { REDIS_DB, REDIS_HOST, REDIS_PASSWORD, REDIS_PORT } from '@bas/config';\nimport { logInfo, logSuccess } from '@bas/utils/logger';\nimport { alarmService } from './index';\nlet queue: kue.Queue;\n\nexport const initQueue = () => {\n  queue = kue.createQueue({\n    prefix: 'alarm',\n    redis: {\n      host: REDIS_HOST,\n      port: REDIS_PORT,\n      auth : REDIS_PASSWORD,\n      db: REDIS_DB\n    },\n  });\n  logInfo('Queue is running');\n  handleQueue(\"alarm-save\", alarmService.saveAlarmFromQueue).then(r => logSuccess(\"Handle queue alarm-save success\"));\n  return queue;\n}\nexport const pushToQueue = async (queueName: string, data: any) => {\n  return queue.create(queueName, data).save();\n}\n\n\nexport const handleQueue = async (queueName: string, handler: (data: any) => Promise<void>) => {\n  queue.process(queueName, async (job: Job, done :DoneCallback) => {\n    try {\n      await handler(job.data);\n      done();\n    } catch (error) {\n      done(error);\n    }\n  });\n}",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/export-data-record-service.ts": "import { log } from '@bas/utils';\nimport Excel from 'exceljs';\nimport { Response } from 'express';\nimport moment from 'moment-timezone';\nimport * as echarts from 'echarts';\nimport { createCanvas } from 'canvas';\nimport { useMessages } from '../locale';\nimport * as _ from 'lodash';\n\nenum SheetName {\n  GENERAL_INFORMATION = 'record-export.sheet.general-information',\n  LINE_CHART = 'record-export.sheet.line-chart',\n  AGGREGATE_TABLE = 'record-export.sheet.aggregate',\n}\n\nconst sheetNames = [SheetName.GENERAL_INFORMATION, SheetName.LINE_CHART, SheetName.AGGREGATE_TABLE];\n\nconst historyColumns = [\n  {\n    key: 'time',\n  },\n  {\n    key: 'zone',\n  },\n  {\n    key: 'leftDistance',\n  },\n  {\n    key: 'leftSpeed',\n  },\n  {\n    key: 'rightDistance',\n  },\n  {\n    key: 'rightSpeed',\n  },\n  {\n    key: 'angle',\n  },\n];\n\nconst generalData = (recordData: any, lang?: string) => {\n  return [\n    [\n      useMessages('record-export.title.berth-name', lang),\n      lang == 'en' ? recordData.berth.nameEn : recordData.berth.name,\n      '',\n      useMessages('record-export.title.anchoring-status', lang),\n      useMessages(`record-export.name.${recordData?.mooringStatus?.toUpperCase()}`, lang),\n    ],\n    [\n      useMessages('record-export.title.vessel-name', lang),\n      recordData.vessel.nameEn,\n      '',\n      useMessages('record-export.title.start-time', lang),\n      moment(recordData.startTime).format('HH:mm:ss:SSS DD-MM-YYYY'),\n    ],\n    [\n      useMessages('record-export.title.session-id', lang),\n      recordData.sessionId,\n      '',\n      useMessages('record-export.title.end-time', lang),\n      moment(recordData.endTime).format('HH:mm:ss:SSS DD-MM-YYYY'),\n    ],\n  ];\n};\n\nconst formatValue = (value: number) => {\n  return value?.toFixed(2) ?? '--';\n};\n\nconst findLatestDataPoint = (start: any, end: any, rangeData: any[]) => {\n  let result = {\n    time: end?.format(),\n    leftDistance: null,\n    rightDistance: null,\n    leftSpeed: null,\n    rightSpeed: null,\n  };\n\n  const dataPoints = rangeData?.filter(\n    (item: any) => moment(item?.time) >= start && moment(item?.time) <= end\n  );\n\n  if (dataPoints?.length > 0) {\n    result = _.last(dataPoints);\n  }\n\n  return result;\n};\n\nconst processingData = (recordData: any[]) => {\n  const result = [];\n  const INTERVAL_IN_SECONDS = 30;\n\n  let startTime = moment(_.first(recordData)?.time);\n  let endTime = moment(_.last(recordData)?.time);\n\n  // while (startTime <= endTime) {\n  //   const dataPoint = findLatestDataPoint(\n  //     startTime.clone(),\n  //     startTime.clone().add(INTERVAL_IN_SECONDS, 'seconds'),\n  //     recordData\n  //   );\n  //\n  //   result.push(dataPoint);\n  //   startTime = startTime.add(INTERVAL_IN_SECONDS, 'seconds');\n  // }\n  return recordData;\n};\n\nconst chartOption = (data: any, prefix: string) => {\n  return {\n    grid: {\n      top: 8,\n      right: 8,\n      bottom: 24,\n      left: 36,\n    },\n    xAxis: {\n      type: 'time',\n      connectNulls: false,\n      // data: chartData?.map((item: any) => moment(item?.time).format('HH:mm:ss')),\n    },\n    yAxis: {\n      type: 'value',\n    },\n    series: [\n      {\n        name: 'distance',\n        data: data?.map((item: any) => [\n          item?.time,\n          formatValue(item?.[`${prefix}Distance`]) || null,\n        ]),\n        type: 'line',\n        smooth: true,\n      },\n      {\n        name: 'speed',\n        data: data?.map((item: any) => [item?.time, formatValue(item?.[`${prefix}Speed`]) || null]),\n        type: 'line',\n        smooth: true,\n      },\n    ],\n    tooltip: {\n      trigger: 'axis',\n    },\n    backgroundColor: '#fff',\n  };\n};\n\nconst historyData = (recordData: any) => {\n  return recordData?.recordHistories.map((item: any) => ({\n    time: moment(item?.time).format('DD-MM-YYYY HH:mm:ss:SSS'),\n    zone:\n      Math.min(\n        item?.angleZone,\n        item?.LSpeedZone,\n        item?.RSpeedZone,\n        item?.LDistanceZone,\n        item?.RDistanceZone\n      ) || '--',\n    leftDistance: formatValue(item?.leftDistance),\n    leftSpeed: formatValue(item?.leftSpeed),\n    rightDistance: formatValue(item?.rightDistance),\n    rightSpeed: formatValue(item?.rightSpeed),\n    angle: item?.angle ? formatValue(Math.abs(item?.angle)) : '--',\n  }));\n};\n\nconst getImageData = (chatData: any, prefix: string) => {\n  const canvas = createCanvas(1200, 400);\n\n  const chart = echarts.init(canvas as any);\n  chart.setOption(chartOption(chatData, prefix));\n\n  return canvas.toDataURL('image/png').replace(/^data:image\\/\\w+;base64,/, '');\n};\n\nconst exportDataToExcel = async (res: Response, recordData: any, lang?: string) => {\n  const workbook = new Excel.Workbook();\n  sheetNames.forEach((sheetName) => {\n    let worksheet = workbook.addWorksheet(useMessages(sheetName, lang), { properties: {} });\n    worksheet.state = 'visible';\n    worksheet.properties.defaultColWidth = 20;\n\n    switch (sheetName) {\n      case SheetName.GENERAL_INFORMATION:\n        worksheet.mergeCells('A1:B1');\n        worksheet.getCell('A1').value = useMessages('record-export.title.general', lang);\n        worksheet.getRow(2).values = [];\n        const generalDatas = generalData(recordData, lang);\n        worksheet.addRows(generalDatas);\n\n        worksheet.getCell('A8').value = useMessages('record-export.name.history', lang);\n        worksheet.getRow(9).values = [];\n        worksheet.addRow([\n          '',\n          '',\n          useMessages('record-export.name.left-sensor', lang),\n          '',\n          useMessages('record-export.name.right-sensor', lang),\n          '',\n          '',\n        ]);\n\n        worksheet.mergeCells('A10:B10');\n        worksheet.mergeCells('C10:D10');\n        worksheet.mergeCells('E10:F10');\n        worksheet.addRow([\n          useMessages('record-export.name.time', lang),\n          useMessages('record-export.name.zone', lang),\n          useMessages('record-export.name.distance', lang),\n          useMessages('record-export.name.speed', lang),\n          useMessages('record-export.name.distance', lang),\n          useMessages('record-export.name.speed', lang),\n          useMessages('record-export.name.angle', lang),\n        ]);\n\n        ['A10', 'C10', 'E10', 'G10', 'A11', 'B11', 'C11', 'D11', 'E11', 'F11', 'G11'].map((key) => {\n          worksheet.getCell(key).fill = {\n            type: 'pattern',\n            pattern: 'solid',\n            fgColor: { argb: 'a7a8a9' },\n          };\n          worksheet.getCell(key).alignment = { vertical: 'middle', horizontal: 'center' };\n          worksheet.getCell(key).border = {\n            top: { style: 'thin', color: { argb: 'ffffff' } },\n            left: { style: 'thin', color: { argb: 'ffffff' } },\n            bottom: { style: 'thin', color: { argb: 'ffffff' } },\n            right: { style: 'thin', color: { argb: 'ffffff' } },\n          };\n        });\n        worksheet.columns = historyColumns;\n        const historyDatas = historyData(recordData);\n        worksheet.addRows(historyDatas);\n        break;\n      case SheetName.LINE_CHART:\n        const chartData = processingData(recordData.chart);\n        const leftSensorImage = getImageData(chartData, 'left');\n        const leftSensorImageId = workbook.addImage({\n          base64: leftSensorImage,\n          extension: 'png',\n        });\n        worksheet.getCell('A1').value = useMessages('record-export.name.left-sensor', lang);\n        worksheet.getRow(2).values = [];\n\n        worksheet.addImage(leftSensorImageId, {\n          tl: { col: 0, row: 2 },\n          ext: { width: 1100, height: 300 },\n        });\n\n        const rightSensorImage = getImageData(chartData, 'right');\n        const rightSensorImageId = workbook.addImage({\n          base64: rightSensorImage,\n          extension: 'png',\n        });\n        worksheet.getCell('A19').value = useMessages('record-export.name.right-sensor', lang);\n        worksheet.getRow(20).values = [];\n\n        worksheet.addImage(rightSensorImageId, {\n          tl: { col: 0, row: 20 },\n          ext: { width: 1100, height: 300 },\n        });\n        break;\n      case SheetName.AGGREGATE_TABLE:\n        worksheet.getCell('A1').value = useMessages('record-export.column.speed', lang);\n        worksheet.getRow(2).values = [];\n\n        worksheet.addRow([\n          useMessages('record-export.name.left-sensor', lang),\n          '',\n          '',\n          useMessages('record-export.name.right-sensor', lang),\n          '',\n          '',\n        ]);\n        worksheet.mergeCells('A03:C03');\n        worksheet.mergeCells('D03:F03');\n        worksheet.addRow([\n          useMessages('record-export.name.min', lang),\n          useMessages('record-export.name.avg', lang),\n          useMessages('record-export.name.max', lang),\n          useMessages('record-export.name.min', lang),\n          useMessages('record-export.name.avg', lang),\n          useMessages('record-export.name.max', lang),\n        ]);\n        worksheet.addRow([\n          recordData.aggregates.minLeftSpeed,\n          recordData.aggregates.avgLeftSpeed,\n          recordData.aggregates.maxLeftSpeed,\n          recordData.aggregates.minRightSpeed,\n          recordData.aggregates.avgRightSpeed,\n          recordData.aggregates.maxRightSpeed,\n        ]);\n\n        worksheet.getRow(6).values = [];\n        worksheet.getCell('A7').value = useMessages('record-export.column.angle', lang);\n        worksheet.getRow(8).values = [];\n        worksheet.addRow([\n          useMessages('record-export.name.min', lang),\n          '',\n          useMessages('record-export.name.avg', lang),\n          '',\n          useMessages('record-export.name.max', lang),\n          '',\n        ]);\n        worksheet.mergeCells('A09:B09');\n        worksheet.mergeCells('C09:D09');\n        worksheet.mergeCells('E09:F09');\n\n        worksheet.addRow([\n          recordData.aggregates.minAngle,\n          '',\n          recordData.aggregates.avgAngle,\n          '',\n          recordData.aggregates.maxAngle,\n          '',\n        ]);\n        worksheet.mergeCells('A10:B10');\n        worksheet.mergeCells('C10:D10');\n        worksheet.mergeCells('E10:F10');\n\n        [\n          'A03',\n          'D03',\n          'A04',\n          'B04',\n          'C04',\n          'D04',\n          'E04',\n          'F04',\n          'A05',\n          'B05',\n          'C05',\n          'D05',\n          'E05',\n          'F05',\n          'A09',\n          'C09',\n          'E09',\n          'A10',\n          'B10',\n          'C10',\n          'D10',\n          'E10',\n          'F10',\n        ].map((key) => {\n          worksheet.getCell(key).fill = {\n            type: 'pattern',\n            pattern: 'solid',\n            fgColor: { argb: 'a7a8a9' },\n          };\n          worksheet.getCell(key).alignment = { vertical: 'middle', horizontal: 'center' };\n          worksheet.getCell(key).border = {\n            top: { style: 'thin', color: { argb: 'ffffff' } },\n            left: { style: 'thin', color: { argb: 'ffffff' } },\n            bottom: { style: 'thin', color: { argb: 'ffffff' } },\n            right: { style: 'thin', color: { argb: 'ffffff' } },\n          };\n        });\n        break;\n    }\n  });\n\n  let filename = `Recording_${recordData.sessionId}_${lang}.xlsx`;\n  log(`Exporting ${filename}...`);\n  res.setHeader(\n    'Content-Type',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n  );\n  res.setHeader('Content-Disposition', 'attachment; filename=' + filename);\n\n  return workbook.xlsx.write(res).then(function () {\n    res.status(200).end();\n  });\n};\n\nexport { exportDataToExcel };\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/kafka-service.ts": "import { APP_NAME, KAFKA_HOST } from '@bas/config';\nimport { Kafka, Consumer } from 'kafkajs';\nimport { logError } from '@bas/utils';\n\nconst kafkaClient = new Kafka({\n  clientId: `bas-client`,\n  brokers: [KAFKA_HOST],\n  retry: {\n    initialRetryTime: 5000,\n    retries: 20,\n  },\n});\n\nconst producer = kafkaClient.producer({\n  allowAutoTopicCreation: true,\n});\n\nconst initKafkaData = async (receiveMessage: Function, consumer: Consumer, topic: string) => {\n  try {\n    await consumer.connect();\n    await consumer.subscribe({\n      topic: APP_NAME == 'uat' ? `${topic}_uat` : topic,\n      fromBeginning: false,\n    });\n\n    await consumer.run({\n      eachMessage: async ({ message, topic: string }) => {\n        // console.log(`[${topic}] Receive message ${message?.value?.toString()}`);\n        receiveMessage(message);\n      },\n    });\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst produceKafkaData = async (topic: string, messages: string) => {\n  try {\n    await producer.connect();\n    await producer.send({\n      topic: APP_NAME == 'uat' ? `${topic}_uat` : topic,\n      messages: [{ value: messages }],\n    });\n    await producer.disconnect();\n  } catch (error) {\n    logError(error);\n  }\n};\n\nconst healthCheck = async () => {\n  try {\n    await producer.connect();\n    await producer.send({\n      topic: 'health-check',\n      messages: [{ value: 'health-check' }],\n    });\n    await producer.disconnect();\n    return true;\n  } catch (error) {\n    console.log('error', error);\n    return false;\n  }\n};\n\nexport { initKafkaData, kafkaClient, produceKafkaData, healthCheck };\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/permission-services.ts": "import { mapApiPermissionsToRoles } from './permission-mapping';\nimport { roleMatrix } from '@bas/constant/role-matrix';\nimport { SystemPermission } from '@bas/constant/system-permission';\n\nexport function getSystemPermissionsFromRoles(roles: string[]): string[] {\n  const systemPermissionsSet: Set<string> = new Set();\n\n  roles.forEach((role) => {\n    const permissions = roleMatrix[role];\n    if (permissions) {\n      permissions.forEach((perm) => systemPermissionsSet.add(perm));\n    }\n  });\n\n  return Array.from(systemPermissionsSet);\n}\n\nexport function getUserPermissions(apiPermissions: string[]) {\n  const roles = mapApiPermissionsToRoles(apiPermissions);\n  const systemPermissions = getSystemPermissionsFromRoles(roles);\n\n  return {\n    roles,\n    systemPermissions,\n  };\n}\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/user-service.ts": "import { BadRequestException, InternalException } from '@bas/api/errors';\nimport { generateJwt, generateJwtSocket, log, randomString } from '@bas/utils';\nimport { compressImage, deleteImage } from '@bas/utils/image';\nimport { REFRESH_TERM } from '@bas/config';\nimport { internalErrorCode } from '@bas/constant';\nimport { AVATAR_FOLDER_PATH_REGEX } from '@bas/constant/path';\nimport { baseDao, refreshTokenDao, userDao } from '@bas/database/dao';\nimport User, { UserInput } from '@bas/database/models/user-model';\n\nimport { UserQueryParams, UserUpdatePayload } from '@bas/service/typing';\nimport { removeTokenByUserId } from '@bas/database/dao/refresh-token-dao';\n\nconst DEFAULT_REFRESH_TERM = 604800000;\n\nconst createUser = async (payload: UserInput, transaction?: any) => {\n  return await User.create(payload, {\n    transaction,\n  });\n};\n\nconst updateUserInformation = async (id: string, payload: UserUpdatePayload, transaction?: any) => {\n  const { email, phone, avatar } = payload;\n\n  const user = await userDao.getOneUserById(id);\n  if (!user) {\n    throw new BadRequestException('User not found');\n  }\n\n  if (!avatar && user.avatar) {\n    deleteImage(user.avatar?.replace(AVATAR_FOLDER_PATH_REGEX, ''));\n    payload.avatar = null;\n  } else {\n    // Avatar url not change\n    if (avatar && user.avatar && avatar.includes(user.avatar)) {\n      payload.avatar = user.avatar;\n    }\n  }\n  await baseDao.updateModel(User, id, payload, transaction);\n  return await userDao.getOneUserById(id);\n};\n\nconst removeTokenByUser = async (userId: string) => {\n  return await refreshTokenDao.removeTokenByUserId(userId);\n};\n\nconst updateUserById = async (id: string, payload: UserUpdatePayload, transaction?: any) => {\n  const { email, phone } = payload;\n  // check email and phone is unique\n  return baseDao.updateModel(User, id, payload, transaction);\n};\n\nconst getAllUsers = async (params?: UserQueryParams) => {\n  return await userDao.getAllWithParams(params);\n};\n\nconst getUserById = async (id: string) => {\n  return await userDao.getOneUserById(id);\n};\n\nconst deleteAccountById = async (id: string) => {\n  const user: User | null = await userDao.getOneUserById(id);\n  if (user) {\n    if (user?.avatar) {\n      deleteImage(user?.avatar);\n    }\n  } else {\n    throw new BadRequestException('User not found', internalErrorCode.RESOURCE_NOT_FOUND);\n  }\n  await removeTokenByUserId(id);\n  return await removeTokenByUserId(id);\n};\n\nconst generateAccessToken = (user: User) => {\n  return generateJwt(user);\n};\n\nconst generateAccessTokenForSocket = (userId: string, roleId: number) => {\n  return generateJwtSocket(userId, roleId);\n};\n\nconst generateRefreshToken = async (user: User, ipAddress: string, transaction?: any) => {\n  return await refreshTokenDao.create(\n    {\n      token: randomString(),\n      userId: user.id,\n      expires: new Date(Date.now() + (REFRESH_TERM ? DEFAULT_REFRESH_TERM : +REFRESH_TERM)),\n      createdByIp: ipAddress,\n    },\n    transaction\n  );\n};\nconst getRefreshToken = async (token: string, ip: string) => {\n  const refreshToken = await refreshTokenDao.findOneByTokenAndIp(token, ip);\n  console.log({ refreshToken, token, ip });\n  if (!refreshToken || !refreshToken.isActive) throw new InternalException('Invalid token');\n  return refreshToken;\n};\n\nconst revokeToken = async (token: string, revokedByIpAddress: string) => {\n  const refreshToken = await getRefreshToken(token, revokedByIpAddress);\n\n  if (!refreshToken.user) return new InternalException('Revoke token failed');\n\n  refreshToken.revoked = new Date();\n  refreshToken.revokedByIp = revokedByIpAddress;\n  await refreshToken.save();\n};\n\nconst cleanupToken = async () => {\n  return await refreshTokenDao.removeUnusedToken();\n};\n\nconst refreshUserToken = async (token: string, ipAddress: string, transaction?: any) => {\n  const refreshToken = await getRefreshToken(token, ipAddress);\n\n  if (!refreshToken.user) throw new InternalException('Refresh token failed');\n\n  const newRefreshToken = await generateRefreshToken(refreshToken.user, ipAddress, transaction);\n\n  refreshToken.revoked = new Date();\n  refreshToken.replaceByToken = newRefreshToken.token;\n  refreshToken.revokedByIp = ipAddress;\n  await refreshToken.save();\n\n  const newAccessToken = generateJwt(refreshToken.user);\n\n  const user = await userDao.getOneUserById(refreshToken.userId);\n\n  return {\n    token: newAccessToken,\n    refreshToken: newRefreshToken.token,\n    data: user,\n  };\n};\n\nconst findUserByRole = async (role: string) => {\n  return await userDao.findUserByRole(role);\n};\n\nexport {\n  deleteAccountById,\n  getAllUsers,\n  createUser,\n  getUserById,\n  updateUserById,\n  revokeToken,\n  generateRefreshToken,\n  generateAccessToken,\n  refreshUserToken,\n  cleanupToken,\n  updateUserInformation,\n  generateAccessTokenForSocket,\n  findUserByRole,\n};\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/realtime-service.ts": "import { logError, logSuccess, trace, unflattenObject, verifyTokenForSocket } from '@bas/utils';\nimport { Namespace, Server } from 'socket.io';\nimport { KafkaMessage } from 'kafkajs';\nimport {\n  berthService,\n  recordHistoryService,\n  recordService,\n  revokeTokenService,\n  userService,\n} from './index';\nimport {\n  AuthSocket,\n  DeviceRealValue,\n  NamespaceRealtimeSocket,\n  PortEventSocketDeviceError,\n  PortEventSocketEndSession,\n  RawRealtimeData,\n  RealtimeKafkaMessage,\n  SocketRealtimeData,\n  TokenData,\n} from './typing';\nimport * as objectMapper from 'object-mapper';\nimport { realtimeMapper } from '@bas/database/mapper/realtime-mapper';\nimport { berthDao, sensorDao } from '@bas/database/dao';\nimport { RecordHistoryInput } from '@bas/database/models/record-history-model';\nimport { DeviceStatus } from '@bas/constant/device-status';\nimport { initKafkaData, kafkaClient } from './kafka-service';\nimport { BAS_DATA_REALTIME, BAS_DEVICE_REALTIME } from '@bas/constant/kafka-topic';\nimport { SENSOR_ERROR_CODE } from '@bas/constant';\nimport moment from 'moment-timezone';\nimport { BerthStatus } from '@bas/constant/berth-status';\nimport { Berth, Sensor } from '@bas/database';\nimport { APP_NAME, LIMIT_CONDITION, SPEED_CONDITION } from '@bas/config';\nimport { DefaultEventsMap } from 'socket.io/dist/typed-events';\nimport { SystemRole } from '@bas/database/master-data/system-role';\nimport { setIntervalAsync } from 'set-interval-async';\nconst TIME_OUT = 30 * 1000;\nconst groupId = `GROUP-${APP_NAME}`;\n\nlet deviceRealtime = new Map<number, DeviceRealValue>();\nlet realtimeSocket: Namespace<DefaultEventsMap, DefaultEventsMap, DefaultEventsMap, any> =\n  null as any;\nconst rooms = new Set<String>();\nlet generalSocket: Namespace<DefaultEventsMap, DefaultEventsMap, DefaultEventsMap, any> =\n  null as any;\nlet berthIsRunning = new Map<\n  number,\n  {\n    timestamp: number;\n    beginTs: number;\n    type: string;\n    isSent: boolean;\n    lostTargetAt?: number;\n    mooringStatus?: string;\n  }\n>();\nconst UUID_SYSTEM = '8dad3a21-802a-4e3d-baa3-8dd28b303a93';\n/**\n * Add new berth to realtime data\n * @param berthId\n * @param leftId\n * @param rightId\n */\nconst addBerthRealtime = (berthId: number, leftId: number, rightId: number) => {\n  deviceRealtime.set(berthId, {\n    left_sensor: {\n      id: leftId,\n      value: null,\n      oldVal: null,\n      status: DeviceStatus.DISCONNECT,\n      timestamp: new Date().getTime(),\n    },\n    right_sensor: {\n      id: rightId,\n      value: null,\n      oldVal: null,\n      status: DeviceStatus.DISCONNECT,\n      timestamp: new Date().getTime(),\n    },\n    berthId: berthId,\n  });\n};\n\n/**\n * Remove berth from realtime data when berth is deleted\n * @param berthId\n *\n */\nconst removeBerthRealtime = (berthId: number) => {\n  deviceRealtime.delete(berthId);\n};\n\n/**\n * Init device data for device realtime when start app\n */\nconst initDeviceData = async () => {\n  const data = await berthService.getAllBerthWithSensor();\n  deviceRealtime.clear();\n  data.forEach((berth) => {\n    if (berth.leftDevice?.id && berth.rightDevice?.id) {\n      deviceRealtime.set(berth.id, {\n        left_sensor: {\n          id: berth.leftDevice?.id,\n          value: berth.leftDevice?.realValue || null,\n          oldVal: berth.leftDevice?.realValue || null,\n          status: berth.leftDevice?.status || DeviceStatus.DISCONNECT,\n          timestamp: new Date().getTime(),\n          ...(!berth.leftDevice?.realValue && {\n            error: 'disconnected',\n          }),\n        },\n        right_sensor: {\n          id: berth.rightDevice?.id,\n          value: berth.rightDevice?.realValue || null,\n          oldVal: berth.rightDevice?.realValue || null,\n          status: berth.rightDevice?.status || DeviceStatus.DISCONNECT,\n          timestamp: new Date().getTime(),\n          ...(!berth.rightDevice?.realValue && {\n            error: 'disconnected',\n          }),\n        },\n        berthId: berth.id,\n      });\n    }\n  });\n};\n\n/**\n * Authorization socket with token\n * @param socket\n * @param next\n */\nconst authorizationSocket = (socket: AuthSocket, next: (err?: any) => void) => {\n  try {\n    const token: string | undefined | string[] = socket.handshake.headers.authorization;\n    if (!token) {\n      return next(new Error('Token is required'));\n    }\n    const userInformation: TokenData | null = verifyTokenForSocket(<string>token);\n    if (!userInformation) {\n      return next(new Error('Token is invalid'));\n    }\n    socket.auth = {\n      userId: userInformation.userId,\n      roleId: userInformation.roleId,\n    };\n    next();\n  } catch (error) {\n    return next(new Error('Token is invalid'));\n  }\n};\n\n/**\n * Get room key\n * @param berthId : string (berthId)\n * @param type : string (bas, config)\n */\nconst getRoomKey = (berthId: string, type: string) => {\n  return `${type}_${berthId}`;\n};\n\n/**\n * Handle join socket. if socket is not auth, disconnect socket\n * @param socket\n */\nconst handleJoinSocket = async (socket: AuthSocket) => {\n  if (!socket.auth) {\n    return;\n  }\n  const { userId } = socket.auth;\n};\n\n/**\n * Handle realtime data when receive data from kafka and emit to socket room with berthId\n * @param realtimeSocket\n * @returns\n */\nconst handleRealtimeData = (realtimeSocket?: Namespace<NamespaceRealtimeSocket>) => {\n  return async (message: KafkaMessage) => {\n    try {\n      const raw: RealtimeKafkaMessage = JSON.parse(message?.value?.toString() || '{}');\n      const objectData: SocketRealtimeData = objectMapper.merge(\n        raw,\n        realtimeMapper\n      ) as SocketRealtimeData;\n      const room = getRoomKey(objectData.berthId.toString(), 'bas');\n      const { data, record } = await processData(objectData);\n      const isRunning = berthIsRunning.get(+objectData.berthId) || null;\n      if (isRunning) {\n        const beginTs = isRunning.beginTs;\n        const type = isRunning.type;\n        berthIsRunning.set(+objectData.berthId, {\n          ...isRunning,\n          type,\n          beginTs,\n          timestamp: new Date().getTime(),\n          isSent: false,\n          ...(!data?.error_code && {\n            lostTargetAt: undefined,\n            mooringStatus: undefined,\n          }),\n        });\n      }\n\n      if (realtimeSocket != null && data != null) {\n        console.log(JSON.stringify(data));\n        realtimeSocket.to(room.toString()).emit('data', JSON.stringify(data));\n        if (data?.error_code) {\n          await handleError(\n            objectData.sessionId,\n            objectData.berthId,\n            data.error_code.toString(),\n            record?.mooringStatus || 'DEPARTING'\n          );\n        } else {\n          if (record?.mooringStatus !== 'DEPARTING') {\n            const speedCondition = Object.values(data?.speed).every((val: any) => {\n              if (!val?.value) {\n                return false;\n              }\n              return val.value < +SPEED_CONDITION;\n            });\n            const distanceCondition = Object.values(data?.distance).every((val: any) => {\n              if (!val?.value) {\n                return false;\n              }\n              return val.value <= +LIMIT_CONDITION;\n            });\n            const isShouldEndRecording = speedCondition && distanceCondition;\n            if (isShouldEndRecording) {\n              const berth = await berthDao.getBerthInfo(objectData.berthId);\n              shouldEndRecording({\n                berth: {\n                  id: objectData.berthId,\n                  name: berth?.name,\n                  nameEn: berth?.nameEn,\n                },\n                sessionId: objectData.sessionId,\n              });\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.log(error);\n      logError(error);\n    }\n  };\n};\n\n/**\n * Init realtime data for visualizing data\n * @param io\n */\nconst initRealtimeData = async (io: Server) => {\n  try {\n    realtimeSocket = io.of('/bas-realtime');\n    realtimeSocket.use(authorizationSocket);\n    realtimeSocket.on('connection', async (socket: AuthSocket) => {\n      setTimeout(function () {\n        if (!socket.auth) {\n          console.log(`Disconnect socket {id: ${socket?.id}`);\n          socket.disconnect(true);\n        }\n      }, TIME_OUT);\n\n      socket.on('join', async (data: any) => {\n        try {\n          const { berthId } = JSON.parse(data);\n          if (!berthId) {\n            return;\n          }\n          const stringBerthId = getRoomKey(berthId, 'bas');\n          socket.join(stringBerthId);\n          rooms.add(stringBerthId);\n        } catch (error) {\n          logError(error);\n        }\n      });\n\n      socket.on('leave', async (data: any) => {\n        try {\n          const { berthId } = JSON.parse(data);\n          if (!berthId) {\n            return;\n          }\n          const stringBerthId = getRoomKey(berthId, 'bas');\n          socket.leave(stringBerthId);\n          // check socket room have socket\n          const clients = await realtimeSocket.in(stringBerthId).fetchSockets();\n          if (clients.length === 0) {\n            rooms.delete(stringBerthId);\n          }\n        } catch (error) {\n          logError(error);\n        }\n      });\n\n      socket.on('disconnect', () => {\n        socket.rooms?.forEach((room: any) => {\n          socket.leave(room);\n        });\n      });\n    });\n\n    const consumer = kafkaClient.consumer({\n      groupId,\n    });\n    await initKafkaData(handleRealtimeData(realtimeSocket), consumer, BAS_DATA_REALTIME);\n  } catch (error) {\n    logError(error);\n  }\n};\n\n/**\n * Clean data before emit to socket room\n * @param data\n * @param berth\n * @returns\n */\nfunction cleanData(data: SocketRealtimeData, berth: Berth | null) {\n  if (!berth?.leftDevice?.name || !berth?.rightDevice?.name) {\n    return;\n  }\n\n  const mapData = (value: any, device: Sensor[]) => {\n    const result: any = {};\n    device.forEach((sensor) => {\n      result[sensor.id] = value[sensor.name]?.value\n        ? {\n            value: value[sensor.name]?.value,\n            alarm: value[sensor.name]?.alarm,\n            zone: value[sensor.name]?.zone,\n          }\n        : null;\n    });\n    return result;\n  };\n\n  return {\n    ...data,\n    distance: mapData(data.distance, [berth?.leftDevice, berth?.rightDevice]),\n    speed: mapData(data.speed, [berth?.leftDevice, berth?.rightDevice]),\n    angle: data.angle?.value\n      ? {\n          value: data.angle?.value,\n          alarm: data.angle?.alarm,\n          zone: data.angle?.zone,\n        }\n      : null,\n  };\n}\n\n/**\n * Process data and save to database, push data point to queue to handle alarm\n * @param objectData\n * @returns\n */\nconst processData = async (objectData: SocketRealtimeData): Promise<any> => {\n  try {\n    const record = await recordService.getRecordById(+objectData.sessionId);\n    const berth = await berthDao.getBerthInfo(objectData.berthId);\n    if (!record || !berth?.leftDevice?.name || !berth?.rightDevice?.name) {\n      return null;\n    }\n    const error_code = SENSOR_ERROR_CODE?.[objectData.error_code?.toString()] || '';\n    const device = errorConverter(error_code);\n    const left = ['both', 'left'].includes(device.side) ? device.status : DeviceStatus.CONNECT;\n    const right = ['both', 'right'].includes(device.side) ? device.status : DeviceStatus.CONNECT;\n\n    await recordHistoryService.createRecordHistory(\n      {\n        leftDistance: objectData.distance[berth?.leftDevice?.name]?.value,\n        rightDistance: objectData.distance[berth?.rightDevice?.name]?.value,\n        leftSpeed: objectData.speed[berth?.leftDevice?.name]?.value,\n        rightSpeed: objectData.speed[berth?.rightDevice?.name]?.value,\n        angle: objectData?.angle?.value,\n        leftStatus: left,\n        rightStatus: right,\n        LDistanceAlarm: objectData.distance[berth?.leftDevice?.name]?.alarm,\n        RDistanceAlarm: objectData.distance[berth?.rightDevice?.name]?.alarm,\n        LSpeedAlarm: objectData.speed[berth?.leftDevice?.name]?.alarm,\n        RSpeedAlarm: objectData.speed[berth?.rightDevice?.name]?.alarm,\n        angleAlarm: objectData.angle?.alarm,\n        LSpeedZone: objectData.speed[berth?.leftDevice?.name]?.zone,\n        RSpeedZone: objectData.speed[berth?.rightDevice?.name]?.zone,\n        LDistanceZone: objectData.distance[berth?.leftDevice?.name]?.zone,\n        RDistanceZone: objectData.distance[berth?.rightDevice?.name]?.zone,\n        angleZone: objectData.angle?.zone,\n        time: moment(objectData.eventTime).utc().toDate(),\n        recordId: record.id,\n      } as RecordHistoryInput,\n      {\n        left: berth.leftDevice?.id,\n        right: berth.rightDevice?.id,\n      },\n      record?.mooringStatus || 'DEPARTING'\n    );\n\n    return {\n      data: cleanData(objectData, berth),\n      record,\n    };\n  } catch (error) {\n    logError(error);\n    throw error;\n  }\n};\n\n/**\n * Convert error code to status and message\n * @param error : string\n *\n */\nconst errorConverter = (error: string) => {\n  const side = error.split('@')?.[1] || '';\n  const errorMessage = error.split('@')?.[0] || '';\n  switch (errorMessage) {\n    case 'disconnected':\n      return {\n        side: side,\n        status: DeviceStatus.DISCONNECT,\n        message: errorMessage,\n      };\n    case 'lost_target':\n      return {\n        side: side,\n        status: DeviceStatus.FAIL,\n        message: errorMessage,\n      };\n    case 'weak_signal':\n      return {\n        side: side,\n        status: DeviceStatus.FAIL,\n        message: errorMessage,\n      };\n    default:\n      return {\n        side: 'both',\n        status: DeviceStatus.CONNECT,\n        message: null,\n      };\n  }\n};\n\n/**\n * Init socket for config popup\n * @param io\n */\nconst initRealtimeDevice = async (io: Server) => {\n  const deviceSocket = io.of('/device-realtime');\n  deviceSocket.use(authorizationSocket);\n  deviceSocket.on('connection', async (socket: AuthSocket) => {\n    await handleJoinSocket(socket);\n    setTimeout(function () {\n      if (!socket.auth) {\n        console.log(`Disconnect socket {id: ${socket?.id}`);\n        socket.disconnect(true);\n      }\n    }, TIME_OUT);\n\n    socket.on('join', async (data: any) => {\n      try {\n        const { berthId } = JSON.parse(data);\n        if (!berthId) {\n          return;\n        }\n        const stringBerthId = getRoomKey(berthId, 'config');\n        socket.join(stringBerthId);\n        rooms.add(stringBerthId);\n      } catch (error) {\n        logError(error);\n      }\n    });\n\n    socket.on('leave', async (data: any) => {\n      try {\n        const { berthId } = JSON.parse(data);\n        if (!berthId) {\n          return;\n        }\n        const stringBerthId = getRoomKey(berthId, 'config');\n        socket.leave(stringBerthId);\n        // check socket room have socket\n        const clients = await deviceSocket.in(stringBerthId).fetchSockets();\n        if (clients.length === 0) {\n          rooms.delete(stringBerthId);\n        }\n      } catch (error) {\n        logError(error);\n      }\n    });\n\n    socket.on('disconnect', () => {\n      socket.rooms?.forEach((room: any) => {\n        socket.leave(room);\n      });\n    });\n  });\n\n  const consumer = kafkaClient.consumer({\n    groupId: groupId + '-device',\n  });\n\n  await initKafkaData(\n    async (message: KafkaMessage) => {\n      const raw: RawRealtimeData = JSON.parse(message?.value?.toString() || '{}');\n      const berthSensor = deviceRealtime.get(+raw.berthId);\n      if (!berthSensor) {\n        return;\n      }\n      const errorInfo = errorConverter(SENSOR_ERROR_CODE[raw?.error_code?.toString()] || '');\n      if (raw.sensorsType !== 'RIGHT') {\n        berthSensor.left_sensor = {\n          ...berthSensor.left_sensor,\n          oldVal: berthSensor.left_sensor.value,\n          value: raw.distance || null,\n          status: errorInfo.status,\n          timestamp: new Date().getTime(),\n          error: errorInfo.message,\n        };\n        // await sensorDao.updateDevice(berthSensor.left_sensor.id, errorInfo.status, +raw.distance);\n      } else {\n        berthSensor.right_sensor = {\n          ...berthSensor.right_sensor,\n          oldVal: berthSensor.right_sensor.value,\n          value: raw.distance || null,\n          status: errorInfo.status,\n          timestamp: new Date().getTime(),\n          error: errorInfo.message,\n        };\n        // await sensorDao.updateDevice(berthSensor.right_sensor.id, errorInfo.status, +raw.distance);\n      }\n      deviceRealtime.set(+raw.berthId, berthSensor);\n    },\n    consumer,\n    BAS_DEVICE_REALTIME\n  );\n  const INTERVAL_TIME = 1000;\n  const TIMEOUT_DEVICE = 1000 * 30;\n\n  setInterval(async () => {\n    // console.log('Device realtime: ', deviceRealtime);\n    for (const berth of deviceRealtime.keys()) {\n      const configData = deviceRealtime.get(berth);\n      if (!configData) {\n        continue;\n      }\n      const now = new Date().getTime();\n      if (\n        configData.left_sensor.timestamp + TIMEOUT_DEVICE < now &&\n        configData.left_sensor.status !== DeviceStatus.DISCONNECT\n        // && configData.left_sensor.oldVal !== configData.left_sensor.value\n      ) {\n        configData.left_sensor = {\n          ...configData.left_sensor,\n          status: DeviceStatus.DISCONNECT,\n          oldVal: configData.left_sensor.value,\n          value: null,\n          error: 'disconnected',\n        };\n      }\n\n      if (\n        configData.right_sensor.timestamp + TIMEOUT_DEVICE < now &&\n        configData.right_sensor.status !== DeviceStatus.DISCONNECT\n        // && configData.right_sensor.value !== configData.right_sensor.oldVal\n      ) {\n        configData.right_sensor = {\n          ...configData.right_sensor,\n          status: DeviceStatus.DISCONNECT,\n          oldVal: configData.right_sensor.value,\n          value: null,\n          error: 'disconnected',\n        };\n      }\n      await sensorDao.updatePairDevice(\n        {\n          id: configData.left_sensor.id,\n          status: configData.left_sensor.status,\n          value: configData.left_sensor.value,\n          oldVal: configData.left_sensor.oldVal,\n          timeout: configData.left_sensor.timestamp + TIMEOUT_DEVICE < now,\n        },\n        {\n          id: configData.right_sensor.id,\n          status: configData.right_sensor.status,\n          value: configData.right_sensor.value,\n          oldVal: configData.right_sensor.oldVal,\n          timeout: configData.right_sensor.timestamp + TIMEOUT_DEVICE < now,\n        }\n      );\n\n      deviceRealtime.set(berth, configData);\n      deviceSocket\n        .to(getRoomKey(berth.toString(), 'config'))\n        .emit('device', JSON.stringify(deviceRealtime.get(berth)));\n    }\n  }, INTERVAL_TIME);\n};\n\n/**\n * emit end session to socket room\n * @param portEventSocketEndSession\n */\nconst shouldEndRecording = (portEventSocketEndSession: PortEventSocketEndSession) => {\n  generalSocket.emit('COMPLETED_SESSION', JSON.stringify(portEventSocketEndSession));\n};\n\n/**\n * Handle error from sensor\n * @param sessionId\n * @param berthId\n * @param code\n * @param mooringStatus [DEPARTING, BERTHING]\n */\nconst handleError = async (\n  sessionId: string,\n  berthId: number,\n  code: string,\n  mooringStatus: string\n) => {\n  try {\n    const berth = await berthDao.getBerthInfo(berthId);\n    if (!berth || !berth.leftDevice || !berth.rightDevice) {\n      return;\n    }\n    const error: string = SENSOR_ERROR_CODE[code];\n    const side = error.split('@')[1];\n    const errorMessage = error.split('@')[0];\n    let isRunning = null;\n    switch (side) {\n      case 'both':\n        // if (['lost_target', 'disconnected'].includes(errorMessage)) {\n        //   if (mooringStatus === 'DEPARTING' && errorMessage === 'lost_target') {\n        //     shouldEndRecording({\n        //       berth: {\n        //         id: berthId,\n        //         name: berth.name,\n        //         nameEn: berth.nameEn,\n        //       },\n        //       sessionId: sessionId,\n        //     });\n        //   }\n        //   if (mooringStatus === 'BERTHING') {\n        //     deviceIsError({\n        //       sessionId: sessionId,\n        //       berth: {\n        //         id: berthId,\n        //         name: berth.name,\n        //         nameEn: berth.nameEn,\n        //       },\n        //       errorCode: errorMessage.toUpperCase(),\n        //     });\n        //   }\n        // }\n        if (errorMessage === 'disconnected') {\n          deviceIsError({\n            sessionId: sessionId,\n            berth: {\n              id: berthId,\n              name: berth.name,\n              nameEn: berth.nameEn,\n            },\n            errorCode: errorMessage.toUpperCase(),\n          });\n        }\n\n        isRunning = berthIsRunning.get(berthId) || null;\n        if (errorMessage === 'lost_target') {\n          if (isRunning && !isRunning?.lostTargetAt) {\n            berthIsRunning.set(berthId, {\n              ...isRunning,\n              lostTargetAt: new Date().getTime(),\n              mooringStatus: mooringStatus,\n            });\n          }\n        } else {\n          if (isRunning && isRunning?.lostTargetAt) {\n            berthIsRunning.set(berthId, {\n              ...isRunning,\n              lostTargetAt: undefined,\n              mooringStatus: undefined,\n            });\n          }\n        }\n        break;\n      default:\n        isRunning = berthIsRunning.get(berthId) || null;\n        if (isRunning && isRunning?.lostTargetAt) {\n          berthIsRunning.set(berthId, {\n            ...isRunning,\n            lostTargetAt: undefined,\n            mooringStatus: undefined,\n          });\n        }\n        break;\n    }\n  } catch (error) {\n    trace(error);\n    logError(error);\n  }\n};\n\n/**\n * Emit device error to socket room\n * @param portEventSocketDeviceError\n */\nconst deviceIsError = (portEventSocketDeviceError: PortEventSocketDeviceError) => {\n  generalSocket.emit('DEVICE_ERROR', JSON.stringify(portEventSocketDeviceError));\n};\n\n/**\n * @description Init socket for general event (device error, end session)\n * @param io\n */\nconst initRealtimeGeneral = async (io: Server) => {\n  generalSocket = io.of('/port-events');\n  generalSocket.use(authorizationSocket);\n  generalSocket.on('connection', async (socket: AuthSocket) => {\n    await handleJoinSocket(socket);\n    setTimeout(function () {\n      if (!socket.auth) {\n        console.log(`Disconnect socket {id: ${socket?.id}`);\n        socket.disconnect(true);\n      }\n    }, TIME_OUT);\n    socket.on('disconnect', () => {});\n  });\n};\n\n/**\n * Watching berth to :\n * - Check berth is receiving data in 30s then send disconnect status to socket room\n * - Check berth when record time is 6 hours then finish this record\n */\nconst watchingBerth = async () => {\n  const INTERVAL_TIME = 1000;\n  const TIMEOUT = 1000 * 30;\n  const TIMEOUT_RECORD = 1000 * 60 * 60 * 6;\n  setIntervalAsync(async () => {\n    for (const [berthId, value] of berthIsRunning) {\n      const now = new Date().getTime();\n      // Check the berth is lost target more than 10s\n      if (value?.lostTargetAt && value?.lostTargetAt + 10000 < now) {\n        const berth = await berthDao.getBerthInfo(berthId);\n        const record = await recordService.getCurrentRecord(berthId);\n        if (!berth || !berth.leftDevice || !berth.rightDevice) {\n          continue;\n        }\n\n        if (!record) {\n          continue;\n        }\n\n        if (value.mooringStatus === 'DEPARTING') {\n          shouldEndRecording({\n            berth: {\n              id: berthId,\n              name: berth?.name,\n              nameEn: berth?.nameEn,\n            },\n            sessionId: record?.sessionId,\n          });\n        } else {\n          deviceIsError({\n            sessionId: record?.sessionId,\n            berth: {\n              id: berthId,\n              name: berth?.name,\n              nameEn: berth?.nameEn,\n            },\n            errorCode: 'LOST_TARGET',\n          });\n        }\n      }\n\n      // Check the record for more than 6 hours\n      if (value.beginTs + TIMEOUT_RECORD < now) {\n        const berth = await berthDao.getBerthInfo(berthId);\n        if (!berth || !berth.leftDevice || !berth.rightDevice) {\n          continue;\n        }\n        //End record\n        console.log('End record: ', berthId);\n        const user = await userService.findUserByRole(SystemRole.ADMIN);\n        if (!user) {\n          continue;\n        }\n        const { isSync } = await berthService.resetBerth({\n          berthId: berthId,\n          status: BerthStatus.MOORING,\n          modifier: user.id,\n          isError: false,\n          isFinish: true,\n        });\n        console.log('End record: ', isSync);\n      }\n\n      // Check the berth is receiving data in 30s\n      if (value.timestamp + TIMEOUT < now && !value.isSent) {\n        berthIsRunning.set(berthId, {\n          ...value,\n          isSent: true,\n        });\n        const res = await recordService.getCurrentRecord(berthId);\n        if (!res) {\n          continue;\n        }\n        const record = unflattenObject(res);\n\n        const error: string = SENSOR_ERROR_CODE[1033];\n        const errorMessage = error.split('@')[0];\n        const room = getRoomKey(berthId.toString(), 'bas');\n        console.log('Disconnect socket room: ', room);\n        if (realtimeSocket) {\n          realtimeSocket.to(room.toString()).emit(\n            'data',\n            JSON.stringify(\n              cleanData(\n                {\n                  distance: {},\n                  speed: {},\n                  timestamp: new Date().getTime(),\n                  eventTime: moment().tz('Asia/Ho_Chi_Minh').toDate().toISOString(),\n                  berthId: berthId,\n                  sessionId: record.id.toString(),\n                  error_code: 1033,\n                },\n                record?.berth || null\n              )\n            )\n          );\n        }\n        deviceIsError({\n          sessionId: record.sessionId,\n          berth: {\n            id: berthId,\n            name: record.berth?.name,\n            nameEn: record.berth?.nameEn,\n          },\n          errorCode: errorMessage.toUpperCase(),\n        });\n      }\n    }\n  }, INTERVAL_TIME);\n};\n\nconst addBerthToWatch = (berthId: number, beginTs: number, type: string) => {\n  berthIsRunning.set(berthId, {\n    timestamp: new Date().getTime(),\n    beginTs,\n    type,\n    isSent: false,\n  });\n};\n\nconst removeBerthFromWatch = (berthId: number) => {\n  berthIsRunning.delete(berthId);\n};\n\nconst initWatchBerth = async () => {\n  const records = await berthDao.getBerthsWithHaveRecording();\n  console.log('Init watch berth: ', records.length);\n  records.forEach((frame: any) => {\n    const beginTs = new Date(frame?.startTime).getTime();\n    console.log('Add berth to watch: ', frame.berth.id + ' ' + beginTs);\n    addBerthToWatch(frame.berth.id, beginTs, frame.mooringStatus);\n  });\n};\n\n/**\n * Init realtime service\n * @param io\n */\nconst init = (io: Server) => {\n  try {\n    revokeTokenService.init();\n    initRealtimeData(io).then(() => logSuccess('Init realtime data successfully'));\n    initDeviceData().then(() =>\n      initRealtimeDevice(io).then(() => logSuccess('Init realtime device successfully'))\n    );\n    initWatchBerth().then(() => watchingBerth());\n    initRealtimeGeneral(io).then(() => logSuccess('Init realtime general successfully'));\n    logSuccess('-----------------Init realtime service successfully-------------');\n  } catch (error) {\n    logError(error);\n  }\n};\n\nexport {\n  init,\n  realtimeSocket,\n  shouldEndRecording,\n  addBerthRealtime,\n  removeBerthRealtime,\n  removeBerthFromWatch,\n  addBerthToWatch,\n};\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/vessel-service.ts": "import { vesselDao } from '@bas/database/dao';\nimport { BadRequestException, InternalException } from '@bas/api/errors';\nimport { internalErrorCode } from '@bas/constant';\nimport { Transaction } from 'sequelize';\n\n\nexport const getVessels = async (params: any) => {\n  return vesselDao.getVessels(params);\n};\n\nexport const createVessel = async (payload: any, t : Transaction) => {\n  return vesselDao.createVessel(payload, t);\n}\n\nexport const getVesselById = async (vesselId: number | undefined) => {\n  if (!vesselId) {\n    throw new BadRequestException('Invalid vessel id', internalErrorCode.BAD_REQUEST);\n  }\n  return vesselDao.getVesselById(vesselId);\n}\nexport const upsertVessel = async (payload: any, t ?: Transaction) => {\n  return vesselDao.upsertVessel(payload, t);\n}\n\nexport const updateVessel = async (vesselId: number | undefined, payload: any, t : Transaction) => {\n  return (await  vesselDao.updateVessel(vesselId, payload, t))[1][0];\n}",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/data-app-service.ts": "import { instance } from '@bas/utils/axios';\nimport { controllerPath } from '@bas/constant';\n\nexport const callLoginFunction = async (username: string, password: string) => {\n  try {\n    const payload = {\n      username,\n      password,\n    };\n    const { data } = await instance.post(\n      controllerPath.BAS_VERSION + controllerPath.AUTH_PATH + controllerPath.IDENTIFIER,\n      payload\n    );\n    return data.data || data;\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n};\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/typing.d.ts": "import { Socket } from 'socket.io';\nimport { BerthStatus } from '@bas/constant/berth-status';\n\nexport interface BaseQueryParams {\n  search?: string;\n  order?: string;\n  mode?: 'ASC' | 'DESC';\n  amount?: number;\n  page?: number;\n}\n\nexport interface UserUpdatePayload {\n  fullName?: string;\n  roleId?: number;\n  phone?: string;\n  avatar?: string | null;\n  email?: string;\n  userPrincipalName?: string;\n}\n\nexport interface UserQueryParams extends BaseQueryParams {\n  roleId?: number;\n}\n\ntype userDataPayload = {\n  userId: string;\n  roleId: number;\n};\n\nexport interface AuthSocket extends Socket {\n  auth?: userDataPayload;\n}\n\nexport interface PortEventSocketEndSession {\n  sessionId: string;\n  berth: {\n    id: number;\n    name?: string;\n    nameEn?: string;\n  };\n}\n\nexport interface PortEventSocketDeviceError {\n  sessionId: string;\n  berth: {\n    id: number;\n    name?: string;\n    nameEn?: string;\n  };\n  errorCode: string;\n}\n\ntype TokenData = {\n  userId: string;\n  roleId: number;\n};\n\nexport interface BerthFilter extends BaseQueryParams {\n  berthId?: number;\n  status?: number;\n  vesselId?: number;\n  page?: number | null | undefined;\n  amount?: number | null | undefined;\n}\n\nexport interface RecordFilter extends BaseQueryParams {\n  berthId?: number;\n  vesselId?: number;\n}\n\nexport interface RecordHistoryQueryParams extends BaseQueryParams {}\n\nexport interface AlarmQueryParams extends BaseQueryParams {\n  type?: string;\n  alarm?: string;\n  berth?: string;\n  withoutPagination?: boolean;\n}\n\ntype SensorData = {\n  [key: string]: {\n    value: number;\n    alarm: number;\n    zone: number;\n  };\n};\n\ntype SocketRealtimeData = {\n  speed: SensorData;\n  distance: SensorData;\n  angle?: {\n    value: number;\n    alarm: number;\n    zone: number;\n  };\n  timestamp: number;\n  berthId: number;\n  eventTime: string;\n  sessionId: string;\n  error_code?: any;\n};\n\ntype SensorPayload = {\n  value: number;\n  status_id: number;\n  zone: number;\n};\n\ntype SensorPairPayload = {\n  [key: number]: SensorPayload;\n};\n\ntype RealtimeKafkaMessage = {\n  speed: SensorPairPayload;\n  distance: SensorPairPayload;\n  angle: SensorPayload;\n  event_time: string;\n  berth_id: number;\n  session_id: string;\n  error_code?: number;\n};\n\nexport interface NamespaceRealtimeSocket {\n  join: (data: any) => void;\n  leave: (data: any) => void;\n  data: (data: string) => void;\n}\n\ntype AlarmDataUnit = {\n  value?: number | null;\n  alarm?: number | null;\n  zone?: number | null;\n  startTime: Date;\n  endTime?: Date | null;\n  recordId: number;\n  side?: number;\n  type?: string;\n};\n\ntype AlarmUnit = {\n  status_id: number;\n  value: number;\n  operator: string;\n};\n\ntype StartRecordAlarmPayload = {\n  distance?: {\n    left_sensor: AlarmUnit;\n    right_sensor: AlarmUnit;\n  };\n  speed?: {\n    left_sensor: AlarmUnit;\n    right_sensor: AlarmUnit;\n  };\n  angle?: AlarmUnit;\n};\n\ntype StartRecordPayload = {\n  berth_id: number;\n  session_id: number;\n  mode: 'start' | 'stop';\n  distance_left_sensor_to_fender?: number;\n  distance_right_sensor_to_fender?: number;\n  distance_between_sensors?: number;\n  limit_zone_1?: number;\n  limit_zone_2?: number;\n  limit_zone_3?: number;\n  alarm?: StartRecordAlarmPayload;\n};\n\ntype DeviceUnit = {\n  id: number;\n  value: number | null;\n  oldVal?: number | null;\n  status: number;\n  error?: string | null;\n  timestamp: number;\n};\n\ntype DeviceRealValue = {\n  left_sensor: DeviceUnit;\n  right_sensor: DeviceUnit;\n  berthId: number;\n};\n\ntype resetBerthParam = {\n  berthId: number;\n  status: BerthStatus;\n  modifier: string;\n  isFinish?: boolean;\n  isError?: boolean;\n};\n\ntype AlarmData = {\n  value: number;\n  alarm: number;\n  zone: number;\n  startTime: Date;\n  endTime?: Date | null;\n  type: string;\n  message?: string | null;\n  side: number;\n  record: {\n    id: number;\n    sessionId: string;\n    berth: {\n      name: string;\n      nameEn: string;\n    };\n  };\n  sensor: {\n    id: number;\n    name: string;\n  };\n};\n\ntype RawRealtimeData = {\n  berthId: number;\n  sensorsType: 'RIGHT' | 'LEFT';\n  speed: number;\n  distance: number;\n  error_code: number;\n};\n\ntype createAlarmPayload = {\n  recordId: number;\n  type: string;\n  value?: number | null;\n  zone?: number | null;\n  alarm: number;\n  startTime: Date;\n  message?: string | null;\n  side: number | null;\n  sensorId: number | null;\n};\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/auth-service.ts": "import { BadRequestException } from '@bas/exceptions';\nimport { dataAppService, userService } from '@bas/service';\nimport { userDao } from '@bas/database/dao';\n\nexport const login = async (\n  username: string,\n  password: string,\n  ipAddress: string\n): Promise<any> => {\n  try {\n    if (!username || !password) {\n      throw new BadRequestException('Username and password are required');\n    }\n    const data = await dataAppService.callLoginFunction(username, password);\n    console.log(data);\n    if (!data) {\n      throw new BadRequestException('Invalid username or password');\n    }\n\n    const user = await userDao.createUsers({\n      originalId: data.user.id,\n      username: data.user.username,\n      fullName: data.user.fullname,\n      email: data.user.email,\n      roleId: data.user.roleId,\n      roleName: data.user.roleName,\n      phone: data.user.phone,\n      permission: data.permission.join(','),\n      avatar: data.user.avatar,\n      orgId: data.user.organization.id,\n      orgName: data.user.organization.name,\n      orgLogo: data.user.organization.url_logo,\n    });\n\n    if (user === null) {\n      throw new BadRequestException('Invalid username or password');\n    }\n\n    const token = userService.generateAccessToken(user);\n    const refreshToken = await userService.generateRefreshToken(user, ipAddress);\n    return {\n      token: token,\n      refreshToken: refreshToken.token,\n      data: {\n        id: user.id,\n        username: user.username,\n        fullName: user.fullName,\n        email: user.email,\n        roleId: user.roleId,\n        roleName: user.roleName,\n        phone: user.phone,\n        avatar: user.avatar,\n        orgId: user.orgId,\n        orgName: user.orgName,\n        orgLogo: user.orgLogo,\n        permission: user.permission.split(','),\n      },\n    };\n  } catch (error) {\n    console.log(error);\n    throw error;\n  }\n};\n",
    "/home/dev/project/cloud-services/backend/bas-api/src/service/record-history-service.ts": "import { recordHistoryDao, alarmDao } from '@bas/database/dao';\nimport { RecordHistoryInput } from '@bas/database/models/record-history-model';\nimport { queueService } from './index';\n\nconst getAllRecordHistoryByRecordIds = async (recordIds: number[]) => {\n  return await recordHistoryDao.getAllRecordHistoryByRecordIds(recordIds);\n};\n\nconst getAllRecordHistoryBetweenTime = async (berthId: number, startTime: Date, endTime: Date) => {\n  return await recordHistoryDao.getAllRecordHistoryBetweenTime(berthId, startTime, endTime);\n};\nconst createRecordHistory = async (\n  data: RecordHistoryInput,\n  sensorIds: { left: number; right: number },\n  status: string\n) => {\n  const recordHistory = await recordHistoryDao.createRecordHistory(data);\n  if (!recordHistory) {\n    throw new Error('Create record history failed');\n  }\n  if (status !== 'DEPARTING') {\n    await queueService.pushToQueue('alarm-save', { dataPoint: data, sensorIds });\n  }\n  return recordHistory;\n};\n\nexport { createRecordHistory, getAllRecordHistoryByRecordIds, getAllRecordHistoryBetweenTime };\n"
}